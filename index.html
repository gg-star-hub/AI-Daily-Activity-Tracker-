<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Qwen 2.5 (0.5B) - Local Browser Chat</title>

  <!-- Markdown Parser (nice bot output) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg: #0f172a;
      --chat-bg: #1e293b;
      --input-bg: #334155;
      --accent: #3b82f6;
      --text: #f8fafc;
      --user-msg: #2563eb;
      --danger: #ef4444;
      --warn: #f59e0b;
      --muted: #94a3b8;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* --- Loading Screen --- */
    #loader {
      position: absolute;
      inset: 0;
      background: var(--bg);
      z-index: 50;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.5s ease;
    }

    .loader-box {
      background: var(--chat-bg);
      padding: 2rem;
      border-radius: 12px;
      width: 92%;
      max-width: 520px;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border: 1px solid var(--input-bg);
    }

    .progress-bar-bg {
      width: 100%;
      height: 8px;
      background: #020617;
      border-radius: 4px;
      margin-top: 15px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.2s;
    }

    .diag {
      margin-top: 12px;
      text-align: left;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: #cbd5e1;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(51,65,85,0.7);
      border-radius: 10px;
      padding: 10px;
      line-height: 1.35;
      max-height: 180px;
      overflow: auto;
      display: none;
      white-space: pre-wrap;
    }

    .diag-toggle {
      margin-top: 10px;
      border: 1px solid rgba(51,65,85,0.7);
      background: rgba(2,6,23,0.35);
      color: #cbd5e1;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    /* --- Chat Interface --- */
    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
      opacity: 0;
      transition: opacity 0.5s;
    }

    header {
      padding: 15px 20px;
      background: var(--chat-bg);
      border-bottom: 1px solid var(--input-bg);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .badge {
      font-size: 0.75rem;
      background: #0f172a;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--input-bg);
      color: var(--muted);
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      scroll-behavior: smooth;
    }

    .msg {
      max-width: 85%;
      padding: 10px 16px;
      border-radius: 10px;
      line-height: 1.5;
      font-size: 0.95rem;
      animation: fadeIn 0.3s ease;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    .msg p { margin: 0; }
    .msg pre { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; overflow-x: auto; }

    .user {
      align-self: flex-end;
      background: var(--user-msg);
      color: white;
      border-bottom-right-radius: 2px;
    }

    .bot {
      align-self: flex-start;
      background: var(--chat-bg);
      border: 1px solid var(--input-bg);
      border-bottom-left-radius: 2px;
    }

    #input-area {
      padding: 20px;
      background: var(--chat-bg);
      border-top: 1px solid var(--input-bg);
      display: flex;
      gap: 10px;
    }

    input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--input-bg);
      color: white;
      padding: 12px;
      border-radius: 8px;
      outline: none;
      font-size: 1rem;
    }

    input:focus { border-color: var(--accent); }

    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: filter 0.2s;
    }

    button:hover { filter: brightness(1.1); }
    button:disabled { background: var(--input-bg); cursor: not-allowed; opacity: 0.7; }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>

  <!--
    COI (Cross-Origin Isolation) is needed for SharedArrayBuffer.
    Some setups fail when COEP is "require-corp" because cross-origin model assets
    may not send CORP headers; "credentialless" is more tolerant.

    This Service Worker injects COOP/COEP headers.
    NOTE: Service Workers require http(s) (e.g., localhost). Not file://
  -->
  <script>
    (function setupCOIServiceWorker() {
      if (window.crossOriginIsolated) return;
      if (!('serviceWorker' in navigator)) return;

      const alreadyReloaded = sessionStorage.getItem('coi_reloaded') === '1';

      const workerScript = `
self.addEventListener('install', () => self.skipWaiting());
self.addEventListener('activate', (e) => e.waitUntil(self.clients.claim()));
self.addEventListener('fetch', (e) => {
  if (e.request.cache === 'only-if-cached' && e.request.mode !== 'same-origin') return;

  e.respondWith((async () => {
    let res;
    try {
      res = await fetch(e.request);
    } catch (err) {
      // If network fails, fall back to default behavior by rethrowing.
      throw err;
    }

    // Opaque responses can't be modified.
    if (!res || res.status === 0) return res;

    const headers = new Headers(res.headers);
    headers.set('Cross-Origin-Opener-Policy', 'same-origin');
    // More tolerant than require-corp; still enables SAB on supported browsers.
    headers.set('Cross-Origin-Embedder-Policy', 'credentialless');

    return new Response(res.body, {
      status: res.status,
      statusText: res.statusText,
      headers,
    });
  })());
});
      `;

      const blob = new Blob([workerScript], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);

      navigator.serviceWorker.register(url).then((reg) => {
        if (reg.active && !navigator.serviceWorker.controller && !alreadyReloaded) {
          sessionStorage.setItem('coi_reloaded', '1');
          location.reload();
        }
      }).catch(() => {
        // UI reports this after DOM is ready.
      });
    })();
  </script>

  <!--
    Robustness patch:
    Some environments throw "Failed to execute 'add' on 'Cache': Request failed".
    This typically happens when a resource fetch fails during caching.

    We make Cache.add/AddAll non-fatal:
    - still try original add
    - if it fails, do a best-effort fetch and continue

    This keeps the app working even if persistent caching is blocked.
  -->
  <script>
    (function patchCacheAddNonFatal() {
      if (!('caches' in window)) return;

      const origOpen = caches.open.bind(caches);
      caches.open = async function(...args) {
        const cache = await origOpen(...args);
        if (cache.__patched_add) return cache;

        cache.__patched_add = true;

        const origAdd = cache.add ? cache.add.bind(cache) : null;
        const origAddAll = cache.addAll ? cache.addAll.bind(cache) : null;

        if (origAdd) {
          cache.add = async (request) => {
            try {
              return await origAdd(request);
            } catch (e) {
              // Best-effort fetch to keep downstream logic happy.
              try {
                await fetch(request, { mode: 'cors', credentials: 'omit', cache: 'no-store' });
              } catch (_) {}
              return undefined;
            }
          };
        }

        if (origAddAll) {
          cache.addAll = async (requests) => {
            // Ensure failures don't abort the whole batch.
            for (const r of requests) {
              try {
                if (cache.add) await cache.add(r);
                else await fetch(r, { mode: 'cors', credentials: 'omit', cache: 'no-store' });
              } catch (_) {}
            }
            return undefined;
          };
        }

        return cache;
      };
    })();
  </script>
</head>
<body>

  <!-- Loader -->
  <div id="loader">
    <div class="loader-box">
      <h2 style="margin-top:0">Initializing Qwen 2.5</h2>
      <p id="status-text" style="color: var(--muted); font-size:0.9rem;">Preparing…</p>
      <div class="progress-bar-bg">
        <div id="progress" class="progress-bar"></div>
      </div>
      <p id="pct" style="margin-bottom:0; font-size:0.8rem; color:#64748b; margin-top:5px;">0%</p>
      <div style="margin-top: 8px; color:#64748b; font-size:0.8rem; line-height:1.35;" id="hint"></div>
      <button class="diag-toggle" id="diag-toggle" type="button" aria-expanded="false">
        Diagnostics
      </button>
      <div class="diag" id="diag"></div>
    </div>
  </div>

  <!-- Main App -->
  <div id="app">
    <header>
      <div style="font-weight:600;">LocalChat</div>
      <div class="badge">Qwen 2.5 (0.5B)</div>
    </header>

    <div id="messages"></div>

    <div id="input-area">
      <input type="text" id="user-input" placeholder="Type a message…" autocomplete="off" />
      <button id="send-btn">Send</button>
    </div>
  </div>

  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm@0.2.46";

    // --------- Model Selection ---------
    const selectedModel = "Qwen2.5-0.5B-Instruct-q4f32_1-MLC";

    // Prefer WebLLM's internal modelLibURLPrefix/version for consistency.
    const MODEL_LIB_BASE = (webllm.modelLibURLPrefix || "https://raw.githubusercontent.com/mlc-ai/binary-mlc-llm-libs/main/web-llm-models/") + (webllm.modelVersion || "v0.2.46") + "/";

    // Use HF repo base URL (not /resolve/main/) for better compatibility.
    const MODEL_REPO = "https://huggingface.co/mlc-ai/Qwen2.5-0.5B-Instruct-q4f32_1-MLC";

    // Candidate wasm names (we'll probe what exists).
    const MODEL_LIB_CANDIDATES = [
      "Qwen2.5-0.5B-Instruct-q4f32_1-ctx32k_cs2k-webgpu.wasm",
      "Qwen2.5-0.5B-Instruct-q4f32_1-ctx4k_cs1k-webgpu.wasm",
      "Qwen2-0.5B-Instruct-q4f32_1-ctx32k_cs2k-webgpu.wasm",
      "Qwen2-0.5B-Instruct-q4f32_1-ctx4k_cs1k-webgpu.wasm",
      "Qwen2.5-0.5B-Instruct-q4f32_1-webgpu.wasm",
      "Qwen2-0.5B-Instruct-q4f32_1-webgpu.wasm",
    ];

    // --------- UI Helpers ---------
    const $ = (id) => document.getElementById(id);
    const $loader = $("loader");
    const $app = $("app");
    const $status = $("status-text");
    const $progress = $("progress");
    const $pct = $("pct");
    const $hint = $("hint");
    const $msgs = $("messages");
    const $input = $("user-input");
    const $btn = $("send-btn");
    const $diag = $("diag");
    const $diagToggle = $("diag-toggle");

    function setHint(text, tone = 'muted') {
      $hint.textContent = text;
      $hint.style.color = tone === 'danger' ? 'var(--danger)' : (tone === 'warn' ? 'var(--warn)' : '#64748b');
    }

    function setStatus(text, tone = 'muted') {
      $status.textContent = text;
      $status.style.color = tone === 'danger' ? 'var(--danger)' : (tone === 'warn' ? 'var(--warn)' : 'var(--muted)');
    }

    function appendMessage(role, text, asMarkdown = true) {
      const div = document.createElement("div");
      div.className = `msg ${role === 'user' ? 'user' : 'bot'}`;
      if (role === 'user') {
        div.textContent = text;
      } else {
        div.innerHTML = asMarkdown ? marked.parse(text) : text;
      }
      $msgs.appendChild(div);
      $msgs.scrollTop = $msgs.scrollHeight;
      return div;
    }

    function showApp() {
      $loader.style.opacity = "0";
      setTimeout(() => {
        $loader.style.display = "none";
        $app.style.opacity = "1";
      }, 500);
    }

    function diagLine(k, v) {
      return `${k}: ${v}`;
    }

    function updateDiag(extra = {}) {
      const lines = [];
      lines.push(diagLine('crossOriginIsolated', String(window.crossOriginIsolated)));
      lines.push(diagLine('serviceWorker.controller', String(!!navigator.serviceWorker?.controller)));
      lines.push(diagLine('navigator.gpu', String(!!navigator.gpu)));
      lines.push(diagLine('webllm.modelVersion', String(webllm.modelVersion || '')));
      lines.push(diagLine('MODEL_LIB_BASE', MODEL_LIB_BASE));
      if (extra.modelLib) lines.push(diagLine('resolved model_lib', extra.modelLib));
      if (extra.note) lines.push(diagLine('note', extra.note));
      if (extra.error) lines.push(diagLine('lastError', extra.error));
      $diag.textContent = lines.join('\n');
    }

    $diagToggle.addEventListener('click', () => {
      const open = $diag.style.display === 'block';
      $diag.style.display = open ? 'none' : 'block';
      $diagToggle.setAttribute('aria-expanded', open ? 'false' : 'true');
    });

    // --------- Self-tests (smoke) ---------
    function assert(name, cond) {
      if (!cond) throw new Error(`Self-test failed: ${name}`);
    }

    function runSelfTests() {
      // Minimal smoke tests for DOM + dependencies.
      assert('marked loaded', typeof window.marked?.parse === 'function');
      assert('#loader exists', !!$loader);
      assert('#app exists', !!$app);
      assert('#messages exists', !!$msgs);
      assert('#user-input exists', !!$input);
      assert('#send-btn exists', !!$btn);
      // WebGPU may be absent in some environments; do not hard-fail here.
      return true;
    }

    // --------- Model lib probing ---------
    async function probeURL(url) {
      // Use GET Range first; HEAD is sometimes blocked.
      try {
        const r = await fetch(url, { method: 'GET', headers: { 'Range': 'bytes=0-0' }, cache: 'no-store', mode: 'cors', credentials: 'omit' });
        return r.ok || r.status === 206;
      } catch (_) {
        return false;
      }
    }

    async function resolveModelLibURL() {
      for (const name of MODEL_LIB_CANDIDATES) {
        const url = MODEL_LIB_BASE + name;
        if (await probeURL(url)) return url;
      }
      return MODEL_LIB_BASE + MODEL_LIB_CANDIDATES[0];
    }

    // --------- WebLLM init + chat ---------
    let engine;
    const messages = [
      { role: "system", content: "You are Qwen, a helpful and concise AI assistant." }
    ];

    async function initialize() {
      try {
        runSelfTests();
      } catch (e) {
        setStatus(e.message, 'danger');
        setHint('A required dependency failed to load. Check the Diagnostics panel.', 'danger');
        updateDiag({ error: e.message });
        return;
      }

      updateDiag();

      if (!navigator.gpu) {
        setStatus('Error: WebGPU is not supported/enabled in this browser.', 'danger');
        setHint('Use Chrome/Edge with WebGPU enabled. WebLLM requires WebGPU.', 'danger');
        return;
      }

      if (!window.crossOriginIsolated) {
        // Don’t hard-fail here; some WebLLM paths can still run, but SAB-dependent paths may fail.
        setStatus('Cross-origin isolation not active (yet).', 'warn');
        setHint('If initialization fails, serve via localhost and reload once so the Service Worker can apply COOP/COEP.', 'warn');
      } else {
        setHint('');
      }

      try {
        setStatus('Starting engine…');

        // First attempt: use WebLLM defaults. This tends to be the most compatible.
        try {
          engine = await webllm.CreateMLCEngine(selectedModel, {
            initProgressCallback: (info) => {
              const p = Math.max(0, Math.min(1, Number(info?.progress ?? 0)));
              const pct = Math.floor(p * 100);
              $progress.style.width = pct + '%';
              $pct.textContent = pct + '%';
              const t = String(info?.text ?? '').replace('Fetching', 'Downloading');
              setStatus(t || 'Downloading…');
            }
          });
        } catch (e1) {
          // Fallback: inject model record with a resolved model_lib URL.
          setStatus('Default config failed, trying patched config…', 'warn');

          const modelLib = await resolveModelLibURL();
          updateDiag({ modelLib, note: 'Using patched appConfig model record' });

          const appConfig = JSON.parse(JSON.stringify(webllm.prebuiltAppConfig ?? { model_list: [] }));
          appConfig.model_list = appConfig.model_list ?? [];

          // Replace or add our record.
          appConfig.model_list = appConfig.model_list.filter(m => m.model_id !== selectedModel);
          appConfig.model_list.push({
            model: MODEL_REPO,
            model_id: selectedModel,
            model_lib: modelLib,
            vram_required_MB: 900,
            low_resource_required: true,
          });

          engine = await webllm.CreateMLCEngine(selectedModel, {
            appConfig,
            initProgressCallback: (info) => {
              const p = Math.max(0, Math.min(1, Number(info?.progress ?? 0)));
              const pct = Math.floor(p * 100);
              $progress.style.width = pct + '%';
              $pct.textContent = pct + '%';
              const t = String(info?.text ?? '').replace('Fetching', 'Downloading');
              setStatus(t || 'Downloading…');
            }
          });
        }

        showApp();
        appendMessage('assistant', 'Loaded. Ask me anything.');
        $input.focus();

      } catch (err) {
        console.error(err);
        const msg = (err && err.message) ? err.message : String(err);
        setStatus('Error initializing model: ' + msg, 'danger');
        updateDiag({ error: msg });

        // Specific hint for Cache.add failures.
        if (String(msg).includes("Failed to execute 'add' on 'Cache'") || String(msg).includes('Cache')) {
          setHint('Caching failed (often due to blocked/failed cross-origin fetch). This build makes cache.add non-fatal. If it still fails, check Network tab for 404/CORS on model files.', 'warn');
        } else if (!window.crossOriginIsolated) {
          setHint('Likely missing cross-origin isolation. Serve via localhost and reload once so the SW can apply COOP/COEP.', 'warn');
        } else {
          setHint('Open Diagnostics and DevTools Console/Network to identify the failing URL.', 'warn');
        }
      }
    }

    async function handleSend() {
      const text = $input.value.trim();
      if (!text || !engine) return;

      $input.value = '';
      $input.disabled = true;
      $btn.disabled = true;

      appendMessage('user', text, false);
      messages.push({ role: 'user', content: text });

      const botBubble = appendMessage('assistant', '…', false);
      let fullResponse = '';

      try {
        const chunks = await engine.chat.completions.create({
          messages,
          stream: true,
          temperature: 0.7,
        });

        for await (const chunk of chunks) {
          const content = chunk?.choices?.[0]?.delta?.content || '';
          fullResponse += content;
          botBubble.innerHTML = marked.parse(fullResponse || '…');
          $msgs.scrollTop = $msgs.scrollHeight;
        }

        messages.push({ role: 'assistant', content: fullResponse });

      } catch (err) {
        console.error(err);
        botBubble.textContent = 'Error: ' + ((err && err.message) ? err.message : String(err));
      } finally {
        $input.disabled = false;
        $btn.disabled = false;
        $input.focus();
      }
    }

    $btn.addEventListener('click', handleSend);
    $input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    });

    initialize();
  </script>
</body>
</html>
