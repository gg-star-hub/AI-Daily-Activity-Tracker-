<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI Daily Activity Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Tailwind & Chart.js -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>

  <!-- DOMPurify for robust sanitization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.6/purify.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <style>
    html, body { height: 100%; }
  </style>
</head>
<body class="bg-gray-900 text-white flex flex-col min-h-screen">
  <!-- Header -->
  <header class="bg-gray-800 p-4 text-center text-xl font-bold">
    AI Daily Activity Tracker
  </header>

  <!-- Logs -->
  <main class="flex-1 p-4 overflow-y-auto">
    <div id="log" class="space-y-3" aria-live="polite"></div>

    <!-- Activity Chart Section -->
    <section id="chartSection" class="mt-6 bg-gray-800 rounded-lg p-4">
      <h3 class="text-sm font-semibold mb-3 text-gray-200">Activity Breakdown</h3>
      <div class="flex items-center justify-center">
        <canvas id="activityChart" aria-label="Activity breakdown chart" role="img" style="max-height:300px; width:100%"></canvas>
      </div>
      <div id="chartFallback" class="hidden text-sm mt-3"></div>
      <p id="chartEmpty" class="text-xs text-gray-400 mt-3 hidden">No logs yet. Log some activities to see the chart.</p>
    </section>
  </main>

  <!-- Floating buttons (right) -->
  <div class="fixed bottom-4 right-4 space-y-2 z-40">
    <button id="fabBtn" class="bg-green-600 hover:bg-green-700 p-4 rounded-full shadow text-xl" aria-label="Log activity">‚ûï</button>
    <button id="clearBtn" class="bg-red-600 hover:bg-red-700 p-4 rounded-full shadow" aria-label="Clear logs">üóëÔ∏è</button>
    <button id="manageBtn" class="bg-blue-600 hover:bg-blue-700 p-4 rounded-full shadow" aria-label="Manage activities">‚öôÔ∏è</button>
  </div>

  <!-- Tools FAB (left) -->
  <div class="fixed bottom-4 left-4 z-50">
    <button id="toolsFab" class="bg-gray-700 hover:bg-gray-600 p-4 rounded-full shadow text-xl" aria-label="Open tools panel">‚ò∞</button>

    <!-- Tools Panel -->
    <div id="toolsPanel" class="hidden absolute bottom-16 left-0 w-80 bg-gray-800 border border-gray-700 rounded-xl shadow-xl p-4">
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-semibold text-sm">Tools</h3>
        <button id="closeTools" class="text-gray-300 hover:text-white" aria-label="Close tools">‚úñ</button>
      </div>

      <!-- Search / Filter / Sort -->
      <div class="space-y-2 mb-3">
        <input id="searchInput" class="w-full p-2 rounded text-black" placeholder="Search feedback or activity‚Ä¶" aria-label="Search logs" />
        <select id="filterActivity" class="w-full p-2 rounded text-black" aria-label="Filter by activity">
          <option value="">All activities</option>
        </select>
        <select id="sortSelect" class="w-full p-2 rounded text-black" aria-label="Sort logs">
          <option value="timeDesc">Newest first</option>
          <option value="timeAsc">Oldest first</option>
          <option value="activityAsc">Activity A‚ÜíZ</option>
          <option value="activityDesc">Activity Z‚ÜíA</option>
        </select>

        <!-- Date range -->
        <div class="grid grid-cols-2 gap-2">
          <input id="startDate" type="date" class="w-full p-2 rounded text-black" aria-label="Start date (filter)" />
          <input id="endDate"   type="date" class="w-full p-2 rounded text-black" aria-label="End date (filter)" />
        </div>

        <!-- Low-memory mode -->
        <label class="mt-1 flex items-center gap-2 text-sm">
          <input id="lowMemToggle" type="checkbox" />
          <span>Low-memory mode (rule-based or smaller AI)</span>
        </label>
      </div>

      <hr class="border-gray-700 my-3" />

      <!-- Export / Import -->
      <div class="grid grid-cols-2 gap-2 mb-2">
        <button id="exportJsonBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs" aria-label="Export logs as JSON">Export JSON</button>
        <button id="exportCsvBtn"  class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs" aria-label="Export logs as CSV">Export CSV</button>
        <button id="importJsonBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs col-span-2" aria-label="Import logs from JSON">Import</button>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
      </div>

      <!-- AI cache / retry / model links -->
      <div class="grid grid-cols-2 gap-2">
        <button id="retryLoadBtn" class="bg-amber-600 hover:bg-amber-500 px-3 py-2 rounded shadow text-xs" aria-label="Retry AI model load">Retry AI Load</button>
        <button id="clearAICacheBtn" class="bg-amber-700 hover:bg-amber-600 px-3 py-2 rounded shadow text-xs" aria-label="Clear AI cache">Clear AI cache</button>
        <button id="modelLinksBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs col-span-2" aria-label="Show model links">Model download links</button>
      </div>
    </div>
  </div>

  <!-- Log Modal -->
  <div id="logModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50" role="dialog" aria-modal="true" aria-labelledby="logTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-80">
      <h2 id="logTitle" class="text-lg font-bold mb-3">Log Activity</h2>

      <label class="block text-sm mb-1">Activity</label>
      <select id="activitySelect" class="w-full p-2 text-black rounded mb-3">
        <option value="" disabled selected>Select activity</option>
      </select>

      <div class="flex items-center justify-between mb-3">
        <label class="flex items-center space-x-2 text-sm">
          <input type="checkbox" id="aiToggle" />
          <span>Enable AI Coach</span>
        </label>
        <span id="modelBadge" class="text-xs text-yellow-400"></span>
      </div>

      <label class="block text-sm mb-1">Choose AI Model</label>
      <select id="modelSelect" class="w-full p-2 text-black rounded mb-3">
        <option value="smollm135">SmolLM2-135M-Instruct (q4, ~80‚Äì120MB)</option>
        <option value="t5small">T5-small (text2text, ~200‚Äì240MB)</option>
      </select>

      <div id="modelInfo" class="text-xs text-yellow-400 mb-3 hidden"></div>

      <div class="flex gap-2">
        <button id="closeLog" class="w-1/2 bg-gray-700 hover:bg-gray-600 py-2 rounded">Close</button>
        <button id="logBtn" class="w-1/2 bg-green-600 hover:bg-green-700 py-2 rounded">Log</button>
      </div>
    </div>
  </div>

  <!-- Manage Modal -->
  <div id="manageModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50" role="dialog" aria-modal="true" aria-labelledby="manageTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-80">
      <h2 id="manageTitle" class="text-lg font-bold mb-3">Manage Activities</h2>
      <input id="newActivityInput" type="text" placeholder="New activity" class="w-full p-2 text-black rounded mb-2" />
      <button id="addActivityBtn" class="w-full bg-blue-600 hover:bg-blue-700 py-2 rounded mb-4">Add</button>
      <ul id="activityList" class="space-y-1 max-h-40 overflow-y-auto mb-3"></ul>
      <button id="backBtn" class="w-full bg-gray-600 hover:bg-gray-500 py-2 rounded">‚¨Ö Go Back</button>
    </div>
  </div>

  <!-- Model Links Modal -->
  <div id="linksModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50" role="dialog" aria-modal="true" aria-labelledby="linksTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-[28rem] max-w-[90vw]">
      <h2 id="linksTitle" class="text-lg font-bold mb-3">Model download pages</h2>
      <ul class="list-disc list-inside space-y-1 text-sm">
        <li><a class="text-blue-300 hover:underline" target="_blank" rel="noopener" href="https://huggingface.co/HuggingFaceTB/SmolLM2-135M-Instruct">HuggingFaceTB/SmolLM2-135M-Instruct</a></li>
        <li><a class="text-blue-300 hover:underline" target="_blank" rel="noopener" href="https://huggingface.co/Xenova/t5-small">Xenova/t5-small</a></li>
      </ul>
      <div class="text-[11px] text-gray-400 mt-2">Tip: first load caches the model locally (IndexedDB + Cache Storage). If the browser struggles, use the Cancel button below and try the smaller model.</div>
      <div class="flex gap-2 mt-4">
        <button id="closeLinks" class="w-1/2 bg-gray-700 hover:bg-gray-600 py-2 rounded">Close</button>
        <button id="prefetchBtn" class="w-1/2 bg-amber-600 hover:bg-amber-500 py-2 rounded">Prefetch selected model</button>
      </div>
    </div>
  </div>

  <!-- Spinner / progress -->
  <div id="spinner"
       class="hidden fixed bottom-16 left-1/2 -translate-x-1/2 bg-yellow-500 text-black px-3 py-2 rounded shadow text-sm z-50"
       role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-live="polite">
    <div class="flex items-center justify-between gap-4">
      <div>
        <div id="spinnerText" class="font-semibold">Downloading AI Coach‚Ä¶</div>
        <div class="w-52 bg-gray-300 h-2 mt-1 rounded">
          <div id="progressBar" class="bg-green-700 h-2 rounded" style="width:0%"></div>
        </div>
        <div id="spinnerSub" class="text-[11px] mt-1 opacity-80"></div>
      </div>
      <button id="cancelDownloadBtn" class="bg-black/70 text-white px-3 py-1 rounded">Cancel</button>
    </div>
  </div>

  <!-- Footer/version -->
  <footer class="text-xs text-gray-400 absolute bottom-1 left-2">Testversion 0.41</footer>

  <script type="module">
    // ---------- Elements ----------
    const logDiv = document.getElementById('log');
    const fabBtn = document.getElementById('fabBtn');
    const clearBtn = document.getElementById('clearBtn');
    const manageBtn = document.getElementById('manageBtn');
    const logModal = document.getElementById('logModal');
    const manageModal = document.getElementById('manageModal');
    const closeLog = document.getElementById('closeLog');
    const backBtn = document.getElementById('backBtn');
    const logBtn = document.getElementById('logBtn');
    const activitySelect = document.getElementById('activitySelect');
    const aiToggle = document.getElementById('aiToggle');
    const modelSelect = document.getElementById('modelSelect');
    const modelBadge = document.getElementById('modelBadge');
    const modelInfo = document.getElementById('modelInfo');
    const newActivityInput = document.getElementById('newActivityInput');
    const addActivityBtn = document.getElementById('addActivityBtn');
    const activityList = document.getElementById('activityList');
    const spinner = document.getElementById('spinner');
    const spinnerText = document.getElementById('spinnerText');
    const spinnerSub = document.getElementById('spinnerSub');
    const progressBar = document.getElementById('progressBar');
    const cancelDownloadBtn = document.getElementById('cancelDownloadBtn');
    const chartSection = document.getElementById('chartSection');
    const chartEmpty = document.getElementById('chartEmpty');
    const chartCanvas = document.getElementById('activityChart');
    const chartFallback = document.getElementById('chartFallback');

    const toolsFab = document.getElementById('toolsFab');
    const toolsPanel = document.getElementById('toolsPanel');
    const closeTools = document.getElementById('closeTools');
    const modelLinksBtn = document.getElementById('modelLinksBtn');

    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const exportCsvBtn  = document.getElementById('exportCsvBtn');
    const importJsonBtn = document.getElementById('importJsonBtn');
    const importFile    = document.getElementById('importFile');
    const retryLoadBtn  = document.getElementById('retryLoadBtn');
    const clearAICacheBtn = document.getElementById('clearAICacheBtn');

    const searchInput   = document.getElementById('searchInput');
    const filterActivity = document.getElementById('filterActivity');
    const sortSelect    = document.getElementById('sortSelect');

    // New elements
    const lowMemToggle = document.getElementById('lowMemToggle');
    const startDate = document.getElementById('startDate');
    const endDate   = document.getElementById('endDate');

    const linksModal = document.getElementById('linksModal');
    const closeLinks = document.getElementById('closeLinks');
    const prefetchBtn = document.getElementById('prefetchBtn');

    // ---------- Storage / DB ----------
    const STORAGE_KEYS = { ACTIVITIES: 'activityList', LOGS: 'activityLogs' };
    const DB_NAME = 'ADAT_DB';
    const DB_VER = 1;
    const STORE = 'kvs';
    const SETTINGS_KEY = 'settings';

    // IndexedDB helpers
    function openDB() {
      return new Promise((resolve) => {
        if (!('indexedDB' in window)) return resolve(null);
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE, { keyPath: 'key' });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(null); // soft fallback
      });
    }
    async function idbSet(key, value) {
      const db = await openDB(); if (!db) return false;
      return new Promise((resolve) => {
        const tx = db.transaction(STORE, 'readwrite');
        tx.objectStore(STORE).put({ key, value });
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => resolve(false);
      });
    }
    async function idbGet(key) {
      const db = await openDB(); if (!db) return null;
      return new Promise((resolve) => {
        const tx = db.transaction(STORE, 'readonly');
        const req = tx.objectStore(STORE).get(key);
        req.onsuccess = () => resolve(req.result?.value ?? null);
        req.onerror = () => resolve(null);
      });
    }

    // ---------- Data ----------
    let activities = [];
    let logs = [];
    let settings = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{"lowMem":false}');
    lowMemToggle.checked = !!settings.lowMem;

    async function hydrateFromStorage() {
      const idbActs = await idbGet(STORAGE_KEYS.ACTIVITIES);
      const idbLogs = await idbGet(STORAGE_KEYS.LOGS);
      activities = Array.isArray(idbActs) ? idbActs
        : JSON.parse(localStorage.getItem(STORAGE_KEYS.ACTIVITIES) || '[]');
      if (!activities.length) activities = ['Eat','Sleep','Work','Exercise','Study','Commute','Socialize','Relax','Shop','Cook'];
      logs = Array.isArray(idbLogs) ? idbLogs
        : JSON.parse(localStorage.getItem(STORAGE_KEYS.LOGS) || '[]');
    }

    // ---------- AI state ----------
    let generator = null;
    let activeModelKey = 'smollm135';  // 'smollm135' | 't5small'
    let activeModelId = null;          // HF repo id
    let activeTask = null;             // 'text-generation' | 'text2text-generation'
    const TIMEOUT_MS = 12 * 60 * 1000; // 12 minutes hard cap
    const BASE_GEN_TIMEOUT = 14000;    // 14s inference
    let logBusy = false;
    let cancelFlag = false;            // soft-cancel for downloads

    // ---------- Model config ----------
    const MODELS = {
      smollm135: {
        id: 'HuggingFaceTB/SmolLM2-135M-Instruct',
        task: 'text-generation',
        note: 'ONNX q4 ~80‚Äì120MB',
        badge: 'SmolLM2-135M (q4)',
        opts: { dtype: 'q4' }
      },
      t5small: {
        id: 'Xenova/t5-small',
        task: 'text2text-generation',
        note: '~200‚Äì240MB first load',
        badge: 'T5-small',
        opts: {}
      }
    };

    // ---------- Chart palette ----------
    const PALETTE = ['#10b981', '#3b82f6', '#ef4444', '#f59e0b'];

    // ---------- Utils ----------
    const sanitize = (s) => DOMPurify.sanitize(String(s), { ALLOWED_TAGS: [], ALLOWED_ATTR: [] });
    const limitSentences = (t, n=4) => t.split(/(?<=[.!?])\s+/).slice(0, n).join(' ');
    function debounce(fn, ms=300){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

    // Clean / de-echo AI output
    function cleanAIText(txt, inputPrompt) {
      if (!txt) return '';
      let out = txt;

      // Strip prompt echoes
      const needle = inputPrompt.trim();
      if (needle) {
        const re = new RegExp(needle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        out = out.replace(re, ' ').trim();
      }
      // Remove boilerplate / headers / preambles
      out = out
        .replace(/^\s*you are a .*?coach.*?:?/i, ' ')
        .replace(/^\s*i am a .*?coach.*?:?/i, ' ')
        .replace(/\b(?:i am|you are)\b[^.!?]{0,80}\bcoach\b[^.!?]*[.!?]/gi, ' ')
        .replace(/^\s*activity:\s*".*?"\s*/i, ' ')
        .replace(/^\s*output:.*$/im, ' ')
        .replace(/^\s*###\s*response:\s*/i, ' ')
        .replace(/^#+.*$/gmi, ' ')
        .replace(/\s{2,}/g, ' ')
        .trim();

      // Split, sanitize, dedupe
      let sentences = out
        .split(/(?<=[.!?])\s+|\n+/)
        .map(s => s.replace(/^[-‚Ä¢\s]+/,'').trim())
        .filter(Boolean);

      const seen = new Set();
      sentences = sentences.filter(s => { const k = s.toLowerCase(); if (seen.has(k)) return false; seen.add(k); return true; });

      // Normalize punctuation
      sentences = sentences.map(s => {
        const trimmed = s.replace(/^["'‚Äú‚Äù]+|["'‚Äú‚Äù]+$/g,'').trim();
        return /[.!?]$/.test(trimmed) ? trimmed : trimmed + '.';
      });

      // Keep 2‚Äì4 short sentences
      sentences.sort((a,b) => a.length - b.length);
      if (sentences.length > 4) sentences = sentences.slice(0,4);

      return sentences.join(' ');
    }

    // Storage warnings
    async function warnIfNearLimit() {
      try {
        if (navigator.storage?.estimate) {
          const { quota, usage } = await navigator.storage.estimate();
          if (usage / quota > 0.8) {
            const percent = ((usage / quota) * 100).toFixed(1);
            alert(`‚ö†Ô∏è Storage at ${percent}% (~${(usage / 1e6).toFixed(1)}MB). Clear logs or cache.`);
          }
        } else {
          const used = Object.keys(localStorage).reduce((sum, k) => sum + (localStorage.getItem(k)?.length || 0), 0);
          if (used > 4.5e6) alert('‚ö†Ô∏è Local storage almost full (~' + (used/1e6).toFixed(2) + 'MB).');
        }
      } catch {}
    }
    async function safeSave(key, val) {
      warnIfNearLimit();
      try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
      try { await idbSet(key, val); } catch {}
    }

    // Rule-based fallback phrases
    function ruleFeedback(a) {
      const m = {
        Eat:'üçΩÔ∏è Good to stay nourished!', Sleep:'üò¥ Rest is essential.', Work:'üíº Keep focused!',
        Exercise:'üèÉ Great energy boost.', Study:'üìö Knowledge is power.', Commute:'üöå Time well spent traveling.',
        Socialize:'ü§ù Stay connected.', Relax:'üßò Calm and balanced.', Shop:'üõí Don‚Äôt overspend!', Cook:'üë©‚Äçüç≥ Healthy eating starts here.'
      };
      return m[a] || 'Great job ‚Äî keep the momentum going!';
    }

    // Chart helpers
    let activityChart = null;
    function getActivityCounts(list = logs) {
      const counts = {};
      for (const l of list) counts[l.activity] = (counts[l.activity] || 0) + 1;
      return counts;
    }
    function renderCountsTable(counts) {
      const total = Object.values(counts).reduce((a,b)=>a+b,0);
      const rows = Object.entries(counts)
        .sort((a,b)=>b[1]-a[1])
        .map(([k,v]) => `<tr><td class="pr-4 py-1">${sanitize(k)}</td><td class="text-right py-1">${v}</td><td class="text-right text-gray-300 py-1">${((v/total)*100).toFixed(1)}%</td></tr>`)
        .join('');
      chartFallback.innerHTML = `
        <div class="rounded border border-gray-700 p-3">
          <div class="text-xs text-gray-400 mb-2">Chart unavailable ‚Äî showing table.</div>
          <table class="text-sm w-full"><tbody>${rows}</tbody></table>
        </div>`;
    }
    function updateChart(filtered = null) {
      const list = filtered || logs;
      const counts = getActivityCounts(list);
      const labels = Object.keys(counts);
      const data = Object.values(counts);

      const isEmpty = data.length === 0;
      chartSection.classList.toggle('hidden', isEmpty);
      chartEmpty.classList.toggle('hidden', !isEmpty);
      if (isEmpty) return;

      const colors = labels.map((_, i) => PALETTE[i % PALETTE.length]);

      if (!window.Chart) {
        chartCanvas.parentElement.classList.add('hidden');
        chartFallback.classList.remove('hidden');
        renderCountsTable(counts);
        return;
      } else {
        chartCanvas.parentElement.classList.remove('hidden');
        chartFallback.classList.add('hidden');
      }

      const ctx = chartCanvas.getContext('2d');
      if (activityChart) {
        activityChart.data.labels = labels;
        activityChart.data.datasets[0].data = data;
        activityChart.data.datasets[0].backgroundColor = colors;
        activityChart.update('none');
        return;
      }
      activityChart = new Chart(ctx, {
        type: 'doughnut',
        data: { labels, datasets: [{ data, backgroundColor: colors, borderWidth: 0 }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: '#e5e7eb' } } } }
      });
    }

    // Filtering / Sorting (with date range)
    function applyFilterAndSort() {
      const q = searchInput.value.trim().toLowerCase();
      const fa = filterActivity.value;
      const sort = sortSelect.value;

      let view = logs.slice();
      if (fa) view = view.filter(l => l.activity === fa);
      if (q) view = view.filter(l =>
        l.activity.toLowerCase().includes(q) || (l.feedback||'').toLowerCase().includes(q)
      );

      // Date filtering (ISO preferred)
      const s = startDate.value ? new Date(startDate.value + 'T00:00:00') : null;
      const e = endDate.value   ? new Date(endDate.value   + 'T23:59:59') : null;
      if (s || e) {
        view = view.filter(l => {
          const t = l.iso || l.time;
          const d = t ? new Date(t) : null;
          if (!d || isNaN(d)) return false;
          if (s && d < s) return false;
          if (e && d > e) return false;
          return true;
        });
      }

      view.sort((a,b) => {
        if (sort === 'timeAsc') return new Date(a.iso || a.time) - new Date(b.iso || b.time);
        if (sort === 'timeDesc') return new Date(b.iso || b.time) - new Date(a.iso || a.time);
        if (sort === 'activityAsc') return a.activity.localeCompare(b.activity);
        if (sort === 'activityDesc') return b.activity.localeCompare(a.activity);
        return 0;
      });

      renderLogs(view);
      updateChart(view);
    }

    // Renderers
    function renderActivities() {
      const current = activitySelect.value;
      activitySelect.innerHTML = '<option value="" disabled>Select activity</option>';
      activities.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a; opt.textContent = a;
        activitySelect.appendChild(opt);
      });
      if (current && activities.includes(current)) activitySelect.value = current;
      else activitySelect.selectedIndex = 0;

      filterActivity.innerHTML = '<option value="">All activities</option>';
      activities.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a; opt.textContent = a;
        filterActivity.appendChild(opt);
      });

      activityList.innerHTML = '';
      activities.forEach((a,i) => {
        const li = document.createElement('li');
        li.className = 'flex justify-between items-center bg-gray-700 rounded px-2 py-1';
        li.innerHTML = `<span>${sanitize(a)}</span>
                        <button class="text-red-300 hover:text-red-200" aria-label="Delete activity ${sanitize(a)}" tabindex="0">‚úñ</button>`;
        const delBtn = li.querySelector('button');
        delBtn.onclick = () => {
          if (activities.length === 1) { alert('Cannot delete the last activity.'); return; }
          if (!confirm(`Delete "${a}"?`)) return;
          activities.splice(i, 1);
          safeSave(STORAGE_KEYS.ACTIVITIES, activities);
          renderActivities();
          applyFilterAndSort();
        };
        delBtn.onkeydown = (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); delBtn.click(); }
        };
        activityList.appendChild(li);
      });
    }

    function renderLogs(list = logs) {
      logDiv.innerHTML = '';
      list.forEach((l) => {
        const isThinking = l.status === 'thinking';
        const isFail = l.status === 'fail';
        const border = isThinking ? 'border-yellow-400' : isFail ? 'border-red-400' : 'border-green-400';
        const titleC = isThinking ? 'text-yellow-300' : isFail ? 'text-red-300' : 'text-green-300';
        const card = document.createElement('div');
        card.className = `bg-gray-800 p-3 rounded border-l-4 ${border}`;
        card.innerHTML = `
          <div class="flex justify-between gap-3">
            <div>
              <div class="font-semibold">${sanitize(l.activity)}</div>
              <div class="text-xs text-gray-400">${sanitize(l.time)}</div>
              <div class="text-[11px] text-yellow-400 mt-0.5">AI Model: ${sanitize(l.model || 'N/A')}</div>
            </div>
            <div class="flex items-start gap-2">
              <button class="text-gray-300 hover:text-white" title="Copy feedback" aria-label="Copy feedback">üìã</button>
              <button class="text-gray-300 hover:text-white" title="Share" aria-label="Share log">üì§</button>
              <button class="text-red-400 hover:text-red-300" title="Delete log" aria-label="Delete log">üóëÔ∏è</button>
            </div>
          </div>
          <div class="${titleC} mt-2">${sanitize(l.feedback || '')}</div>
        `;
        const [copyBtn, shareBtn, delBtn] = card.querySelectorAll('button');

        copyBtn.onclick = async () => {
          try { await navigator.clipboard.writeText(l.feedback || ''); alert('Copied to clipboard.'); }
          catch { alert('Could not copy.'); }
        };
        shareBtn.onclick = async () => {
          const text = `Activity: ${l.activity}\nTime: ${l.time}\nFeedback: ${l.feedback || ''}`;
          if (navigator.share) {
            try { await navigator.share({ title: 'My Activity Log', text }); } catch {}
          } else {
            try { await navigator.clipboard.writeText(text); alert('Copied (no native share on this device).'); }
            catch { alert('Could not share or copy.'); }
          }
        };
        delBtn.onclick = () => {
          if (!confirm('Delete this log?')) return;
          const ix = logs.indexOf(l);
          if (ix >= 0) logs.splice(ix, 1);
          safeSave(STORAGE_KEYS.LOGS, logs);
          applyFilterAndSort();
        };
        logDiv.appendChild(card);
      });
    }

    // Model selection -> config (respects low-memory mode)
    function applyModelSelection() {
      const key = modelSelect.value;
      if (settings.lowMem && key === 't5small') {
        modelSelect.value = 'smollm135';
      }
      const cfgKey = modelSelect.value;
      activeModelKey = cfgKey;
      const cfg = MODELS[cfgKey];
      activeModelId = cfg.id;
      activeTask   = cfg.task;
      modelBadge.textContent = cfg.badge;
      spinnerSub.textContent = `${cfg.note}, cached after first load`;
    }

    // Modal focus trap
    function trapFocus(modal) {
      const focusable = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      if (!focusable.length) return () => {};
      const first = focusable[0], last = focusable[focusable.length - 1];
      function handler(e) {
        if (e.key !== 'Tab') return;
        if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
        else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
      }
      modal.addEventListener('keydown', handler);
      first.focus();
      return () => modal.removeEventListener('keydown', handler);
    }
    let untrap = () => {};

    // Transformers.js loader
    async function importTransformers() {
      return await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.2');
    }

    // Download cancel (soft)
    cancelDownloadBtn.onclick = () => { cancelFlag = true; spinner.classList.add('hidden'); };

    // Model loader with WASM guard and backoff
    async function loadModel() {
      if (!navigator.onLine) { alert('‚ö†Ô∏è Offline. AI Coach needs internet.'); aiToggle.checked = false; return null; }
      if (!window.WebAssembly || !WebAssembly.compile) {
        alert('‚ö†Ô∏è WebAssembly unsupported. AI Coach unavailable. Falling back to rule-based feedback.');
        aiToggle.checked = false;
        return null;
      }

      const { pipeline } = await importTransformers();
      const attempts = [0, 2000, 5000]; // backoff (ms)
      cancelFlag = false;

      for (let i = 0; i < attempts.length; i++) {
        try {
          spinner.classList.remove('hidden');
          spinnerText.textContent = `Downloading ${activeModelId}‚Ä¶`;
          progressBar.style.width = '0%';
          spinner.setAttribute('aria-valuenow', '0');

          const cfg = MODELS[activeModelKey];
          const opts = {
            progress_callback: (p) => {
              if (cancelFlag) return;
              if (p && p.loaded && p.total) {
                const pct = Math.floor((p.loaded / p.total) * 100);
                progressBar.style.width = pct + '%';
                spinnerText.textContent = `Downloading‚Ä¶ ${pct}%`;
                spinnerSub.textContent = `Loaded ${(p.loaded / 1e6).toFixed(1)}MB of ${(p.total / 1e6).toFixed(1)}MB`;
                spinner.setAttribute('aria-valuenow', String(pct));
              }
            }
          };
          // Prefer WebGPU first; then CPU/WASM to reduce crashes
          opts.device = (i === 0 && navigator.gpu) ? 'webgpu' : 'cpu';
          Object.assign(opts, cfg.opts);

          const gen = await Promise.race([
            pipeline(cfg.task, cfg.id, opts),
            new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), TIMEOUT_MS))
          ]);

          if (cancelFlag) { cancelFlag = false; return null; }

          spinnerText.textContent = '‚úÖ AI Coach ready (cached)';
          setTimeout(() => spinner.classList.add('hidden'), 300);
          return gen;
        } catch (e) {
          console.warn(`Model load attempt ${i+1} failed:`, e.message);
          await new Promise(r => setTimeout(r, attempts[i]));
        } finally {
          setTimeout(() => spinner.classList.add('hidden'), 300);
        }
      }

      // Fallback: if T5-small fails, switch to SmolLM2-135M
      if (activeModelKey === 't5small') {
        console.warn('Falling back to SmolLM2-135M due to load failure.');
        activeModelKey = 'smollm135';
        modelSelect.value = 'smollm135';
        applyModelSelection();
        generator = await loadModel();
        if (generator) {
          const cfg = MODELS[activeModelKey];
          modelInfo.textContent = `Active: ${cfg.badge}`;
          modelInfo.classList.remove('hidden');
          return generator;
        }
      }

      alert('‚ö†Ô∏è Failed to load AI Coach after multiple attempts. Using rule-based feedback.');
      aiToggle.checked = false;
      return null;
    }

    // Prompt builder
    function buildPrompt(activity) {
      const act = String(activity).trim();
      return [
        'You are a wellbeing coach.',
        `Write 2‚Äì4 short, specific, encouraging sentences focused on momentum, the next tiny step, and consistency for the activity: "${act}".`,
        'Do not repeat the instruction or the quoted text. No preamble. No self-reference.',
        '### Response:'
      ].join(' ');
    }

    async function aiCoachFeedback(activity) {
      const input = buildPrompt(activity);
      const cores = navigator.hardwareConcurrency || 4;
      const GEN_MS = Math.min(28000, Math.max(10000, cores < 4 ? 18000 : BASE_GEN_TIMEOUT));
      try {
        const lowMem = !!settings.lowMem;
        const genOpts = {
          max_new_tokens: lowMem ? 48 : 80,
          return_full_text: false,
          do_sample: true,
          temperature: lowMem ? 0.6 : 0.7,
          top_p: 0.9,
          repetition_penalty: 1.15
        };

        const out = await Promise.race([
          generator(input, genOpts),
          new Promise((_, rej) => setTimeout(() => rej(new Error('AI timeout')), GEN_MS))
        ]);

        let txt = Array.isArray(out) ? (out[0]?.generated_text ?? '') : (out?.generated_text ?? '');
        if (txt && input && txt.toLowerCase().startsWith(input.toLowerCase())) {
          txt = txt.slice(input.length);
        }
        txt = cleanAIText(txt, input).trim();

        if (!txt || /^i am\b/i.test(txt) || /^you are\b/i.test(txt)) {
          txt = ruleFeedback(activity);
        }
        txt = limitSentences(txt, 4);
        return txt || 'Keep it up!';
      } catch (e) {
        console.error('AI feedback fail:', e);
        return `‚ö†Ô∏è AI Coach error (${e.message}). ${ruleFeedback(activity)}`;
      }
    }

    // Export / Import
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      URL.revokeObjectURL(url); a.remove();
    }
    exportJsonBtn.onclick = () => {
      const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json;charset=utf-8' });
      downloadBlob(blob, 'activity_logs.json');
    };
    exportCsvBtn.onclick = () => {
      const rows = [['Time','ISO','Activity','Model','Status','Feedback'], ...logs.map(l => [l.time, l.iso || '', l.activity, l.model||'', l.status||'', l.feedback||''])];
      const csv = '\uFEFF' + rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\r\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      downloadBlob(blob, 'activity_logs.csv');
    };
    importJsonBtn.onclick = () => importFile.click();
    importFile.onchange = async () => {
      const f = importFile.files[0]; if (!f) return;
      try {
        const text = await f.text();
        const data = JSON.parse(text);
        if (!Array.isArray(data)) throw new Error('Invalid file format.');
        const validLog = l => l.activity && (l.time || l.iso) && typeof l.feedback === 'string' && typeof l.status === 'string';
        const validData = data.filter(validLog);
        if (!validData.length) throw new Error('No valid logs in file.');
        const mode = confirm('Replace existing logs? (OK = Replace, Cancel = Merge)') ? 'replace' : 'merge';
        logs = (mode === 'replace') ? validData : logs.concat(validData);
        await safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();
        alert(`Imported ${validData.length} valid logs.`);
      } catch (e) { alert('Import failed: ' + e.message); }
      importFile.value = '';
    };

    // AI Cache clear (best effort)
    clearAICacheBtn.onclick = async () => {
      let cleared = false;
      try {
        if ('caches' in window) {
          const names = await caches.keys();
          for (const n of names) {
            if (/transformers|huggingface|hf|onnx|model/i.test(n)) {
              await caches.delete(n); cleared = true;
            }
          }
        }
      } catch {}
      try {
        if (indexedDB && indexedDB.databases) {
          const dbs = await indexedDB.databases();
          for (const db of dbs) {
            if (db.name && /transformers|huggingface|hf|onnx|model/i.test(db.name)) {
              indexedDB.deleteDatabase(db.name); cleared = true;
            }
          }
        }
      } catch {}
      generator = null;
      alert((cleared ? '‚úÖ' : '‚ÑπÔ∏è') + ' AI cache cleared (best effort). Models will re-download when needed.');
    };

    // Retry load
    retryLoadBtn.onclick = async () => {
      if (!aiToggle.checked) aiToggle.checked = true;
      generator = await loadModel();
      if (generator) {
        const cfg = MODELS[activeModelKey];
        modelInfo.textContent = `Active: ${cfg.badge}`;
        modelInfo.classList.remove('hidden');
      }
    };

    // Tools Panel interactions
    toolsFab.onclick = (e) => { e.stopPropagation(); toolsPanel.classList.toggle('hidden'); };
    closeTools.onclick = () => toolsPanel.classList.add('hidden');
    window.addEventListener('click', (e) => { if (!toolsPanel.contains(e.target) && e.target !== toolsFab) toolsPanel.classList.add('hidden'); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') toolsPanel.classList.add('hidden'); });

    // Model Links modal
    modelLinksBtn.onclick = () => { linksModal.classList.remove('hidden'); untrap = trapFocus(linksModal); };
    closeLinks.onclick = () => { linksModal.classList.add('hidden'); untrap(); };
    prefetchBtn.onclick = async () => {
      if (!aiToggle.checked) aiToggle.checked = true; // will show spinner during load
      generator = await loadModel();
      if (generator) {
        const cfg = MODELS[activeModelKey];
        modelInfo.textContent = `Active: ${cfg.badge}`;
        modelInfo.classList.remove('hidden');
        linksModal.classList.add('hidden');
        untrap();
      }
    };

    // Events: open/close modals
    const openLog = () => { logModal.classList.remove('hidden'); untrap = trapFocus(logModal); };
    fabBtn.onclick = openLog;
    manageBtn.onclick = () => { manageModal.classList.remove('hidden'); untrap = trapFocus(manageModal); };
    closeLog.onclick = () => { logModal.classList.add('hidden'); untrap(); };
    backBtn.onclick = () => { manageModal.classList.add('hidden'); untrap(); };

    // Close on ESC / outside (modals)
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') { logModal.classList.add('hidden'); manageModal.classList.add('hidden'); linksModal.classList.add('hidden'); untrap(); }
    });
    window.addEventListener('click', (e) => {
      if (e.target === logModal) { logModal.classList.add('hidden'); untrap(); }
      if (e.target === manageModal) { manageModal.classList.add('hidden'); untrap(); }
      if (e.target === linksModal) { linksModal.classList.add('hidden'); untrap(); }
    });

    // Clear logs
    clearBtn.onclick = async () => {
      if (confirm('Clear all logs?')) {
        logs = [];
        await safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();
      }
    };

    // Add activity (debounced)
    addActivityBtn.onclick = debounce(async () => {
      const val = newActivityInput.value.trim();
      if (!val) { alert('Enter activity.'); return; }
      if (activities.includes(val)) { alert('Activity exists.'); return; }
      activities.push(val);
      await safeSave(STORAGE_KEYS.ACTIVITIES, activities);
      newActivityInput.value = '';
      renderActivities();
      applyFilterAndSort();
    }, 250);

    // Low-memory toggle persist
    lowMemToggle.onchange = async () => {
      settings.lowMem = lowMemToggle.checked;
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      if (settings.lowMem) {
        modelSelect.value = 'smollm135';
        applyModelSelection();
        generator = null; // free model; will lazy-load smaller one if needed
        alert('Low-memory mode ON: using smaller model or rule-based.');
      }
    };

    // AI toggle -> lazy load model
    aiToggle.onchange = async () => {
      if (!aiToggle.checked) return;
      if (!generator) {
        applyModelSelection();
        generator = await loadModel();
      }
      if (generator) {
        const cfg = MODELS[activeModelKey];
        modelInfo.textContent = `Active: ${cfg.badge}`;
        modelInfo.classList.remove('hidden');
      }
    };

    // Log flow with correct fallbacks (includes ISO timestamp)
    logBtn.onclick = async () => {
      if (logBusy) return;
      logBusy = true;
      try {
        const act = activitySelect.value;
        if (!act) { alert('Please select an activity.'); return; }

        const aiOn = aiToggle.checked;

        // Rule-based path
        if (!aiOn || !generator) {
          const now = new Date();
          const entry = {
            activity: act,
            time: now.toLocaleString(),
            iso: now.toISOString(),
            model: aiOn && !generator ? 'AI unavailable' : 'N/A',
            feedback: aiOn && !generator ? `‚ö†Ô∏è AI Coach unavailable. ${ruleFeedback(act)}` : ruleFeedback(act),
            status: aiOn && !generator ? 'fail' : 'done'
          };
          logs.push(entry);
          await safeSave(STORAGE_KEYS.LOGS, logs);
          applyFilterAndSort();
          logModal.classList.add('hidden');
          return;
        }

        // AI path
        const start = new Date();
        const entry = {
          activity: act,
          time: start.toLocaleString(),
          iso: start.toISOString(),
          model: MODELS[activeModelKey].badge,
          feedback: 'ü§ñ AI Coach is thinking‚Ä¶',
          status: 'thinking'
        };
        logs.push(entry);
        await safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();

        try {
          const feedback = await aiCoachFeedback(act);
          entry.feedback = feedback;
          entry.status = feedback.startsWith('‚ö†Ô∏è') ? 'fail' : 'done';
        } catch (e) {
          entry.feedback = `‚ö†Ô∏è AI Coach error. ${ruleFeedback(act)}`;
          entry.status = 'fail';
        }

        await safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();
        logModal.classList.add('hidden');
      } finally {
        logBusy = false;
      }
    };

    // Filters/sort handlers
    searchInput.oninput = debounce(applyFilterAndSort, 150);
    filterActivity.onchange = applyFilterAndSort;
    sortSelect.onchange = applyFilterAndSort;
    startDate.onchange = applyFilterAndSort;
    endDate.onchange = applyFilterAndSort;

    // ---------- Init ----------
    applyModelSelection(); // prime model labels
    async function init() {
      await hydrateFromStorage();
      renderActivities();
      applyFilterAndSort();
    }
    init();
  </script>
</body>
</html>
