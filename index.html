<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Qwen 2.5 (0.5B) - Local Browser Chat</title>

  <!-- Markdown Parser (nice bot output) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg: #0f172a;
      --chat-bg: #1e293b;
      --input-bg: #334155;
      --accent: #3b82f6;
      --text: #f8fafc;
      --user-msg: #2563eb;
      --danger: #ef4444;
      --warn: #f59e0b;
      --muted: #94a3b8;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* --- Loading Screen --- */
    #loader {
      position: absolute;
      inset: 0;
      background: var(--bg);
      z-index: 50;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.5s ease;
    }

    .loader-box {
      background: var(--chat-bg);
      padding: 2rem;
      border-radius: 12px;
      width: 92%;
      max-width: 560px;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border: 1px solid var(--input-bg);
    }

    .progress-bar-bg {
      width: 100%;
      height: 8px;
      background: #020617;
      border-radius: 4px;
      margin-top: 15px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.2s;
    }

    .diag {
      margin-top: 12px;
      text-align: left;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: #cbd5e1;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(51,65,85,0.7);
      border-radius: 10px;
      padding: 10px;
      line-height: 1.35;
      max-height: 220px;
      overflow: auto;
      display: none;
      white-space: pre-wrap;
    }

    .diag-toggle {
      margin-top: 10px;
      border: 1px solid rgba(51,65,85,0.7);
      background: rgba(2,6,23,0.35);
      color: #cbd5e1;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    /* --- Chat Interface --- */
    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
      opacity: 0;
      transition: opacity 0.5s;
    }

    header {
      padding: 15px 20px;
      background: var(--chat-bg);
      border-bottom: 1px solid var(--input-bg);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .badge {
      font-size: 0.75rem;
      background: #0f172a;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--input-bg);
      color: var(--muted);
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      scroll-behavior: smooth;
    }

    .msg {
      max-width: 85%;
      padding: 10px 16px;
      border-radius: 10px;
      line-height: 1.5;
      font-size: 0.95rem;
      animation: fadeIn 0.3s ease;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    .msg p { margin: 0; }
    .msg pre { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; overflow-x: auto; }

    .user {
      align-self: flex-end;
      background: var(--user-msg);
      color: white;
      border-bottom-right-radius: 2px;
    }

    .bot {
      align-self: flex-start;
      background: var(--chat-bg);
      border: 1px solid var(--input-bg);
      border-bottom-left-radius: 2px;
    }

    #input-area {
      padding: 20px;
      background: var(--chat-bg);
      border-top: 1px solid var(--input-bg);
      display: flex;
      gap: 10px;
    }

    input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--input-bg);
      color: white;
      padding: 12px;
      border-radius: 8px;
      outline: none;
      font-size: 1rem;
    }

    input:focus { border-color: var(--accent); }

    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: filter 0.2s;
    }

    button:hover { filter: brightness(1.1); }
    button:disabled { background: var(--input-bg); cursor: not-allowed; opacity: 0.7; }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>

  <!--
    COI (Cross-Origin Isolation) is needed for SharedArrayBuffer.
    "credentialless" is generally more tolerant than "require-corp".

    This Service Worker injects COOP/COEP headers.
    NOTE: Service Workers require http(s) (e.g., localhost). Not file://
  -->
  <script>
    (function setupCOIServiceWorker() {
      if (window.crossOriginIsolated) return;
      if (!('serviceWorker' in navigator)) return;

      const alreadyReloaded = sessionStorage.getItem('coi_reloaded') === '1';

      const workerScript = `
self.addEventListener('install', () => self.skipWaiting());
self.addEventListener('activate', (e) => e.waitUntil(self.clients.claim()));
self.addEventListener('fetch', (e) => {
  if (e.request.cache === 'only-if-cached' && e.request.mode !== 'same-origin') return;

  e.respondWith((async () => {
    const res = await fetch(e.request);
    if (!res || res.status === 0) return res; // opaque can't be changed

    const headers = new Headers(res.headers);
    headers.set('Cross-Origin-Opener-Policy', 'same-origin');
    headers.set('Cross-Origin-Embedder-Policy', 'credentialless');

    return new Response(res.body, {
      status: res.status,
      statusText: res.statusText,
      headers,
    });
  })());
});
      `;

      const blob = new Blob([workerScript], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);

      navigator.serviceWorker.register(url).then((reg) => {
        if (reg.active && !navigator.serviceWorker.controller && !alreadyReloaded) {
          sessionStorage.setItem('coi_reloaded', '1');
          location.reload();
        }
      }).catch(() => {
        // UI will report this.
      });
    })();
  </script>

  <!--
    Robustness patch:
    Some environments throw "Failed to execute 'add' on 'Cache': Request failed".
    We make Cache.add/AddAll non-fatal.
  -->
  <script>
    (function patchCacheAddNonFatal() {
      if (!('caches' in window)) return;

      const origOpen = caches.open.bind(caches);
      caches.open = async function(...args) {
        const cache = await origOpen(...args);
        if (cache.__patched_add) return cache;
        cache.__patched_add = true;

        const origAdd = cache.add ? cache.add.bind(cache) : null;
        const origAddAll = cache.addAll ? cache.addAll.bind(cache) : null;

        if (origAdd) {
          cache.add = async (request) => {
            try { return await origAdd(request); }
            catch (_) {
              try { await fetch(request, { mode: 'cors', credentials: 'omit', cache: 'no-store' }); }
              catch (_) {}
              return undefined;
            }
          };
        }

        if (origAddAll) {
          cache.addAll = async (requests) => {
            for (const r of requests) {
              try {
                if (cache.add) await cache.add(r);
                else await fetch(r, { mode: 'cors', credentials: 'omit', cache: 'no-store' });
              } catch (_) {}
            }
            return undefined;
          };
        }

        return cache;
      };
    })();
  </script>
</head>
<body>

  <!-- Loader -->
  <div id="loader">
    <div class="loader-box">
      <h2 style="margin-top:0">Initializing Qwen 2.5</h2>
      <p id="status-text" style="color: var(--muted); font-size:0.9rem;">Preparing…</p>
      <div class="progress-bar-bg">
        <div id="progress" class="progress-bar"></div>
      </div>
      <p id="pct" style="margin-bottom:0; font-size:0.8rem; color:#64748b; margin-top:5px;">0%</p>
      <div style="margin-top: 8px; color:#64748b; font-size:0.8rem; line-height:1.35;" id="hint"></div>
      <button class="diag-toggle" id="diag-toggle" type="button" aria-expanded="false">Diagnostics</button>
      <div class="diag" id="diag"></div>
    </div>
  </div>

  <!-- Main App -->
  <div id="app">
    <header>
      <div style="font-weight:600;">LocalChat</div>
      <div class="badge">Qwen 2.5 (0.5B)</div>
    </header>

    <div id="messages"></div>

    <div id="input-area">
      <input type="text" id="user-input" placeholder="Type a message…" autocomplete="off" />
      <button id="send-btn">Send</button>
    </div>
  </div>

  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm@0.2.46";

    // ===== Expected behavior =====
    // This page should:
    // 1) Initialize WebLLM in the browser via WebGPU.
    // 2) Download model + wasm runtime libraries from public CDNs.
    // 3) Provide a local chat UI streaming responses.
    //
    // If you want different behavior (offline-first caching, different model, etc.), specify it.

    // --------- Model Selection ---------
    const selectedModel = "Qwen2.5-0.5B-Instruct-q4f32_1-MLC";
    const MODEL_REPO = "https://huggingface.co/mlc-ai/Qwen2.5-0.5B-Instruct-q4f32_1-MLC";

    // Candidate wasm filenames (we'll probe what exists).
    const MODEL_LIB_FILENAMES = [
      "Qwen2.5-0.5B-Instruct-q4f32_1-ctx32k_cs2k-webgpu.wasm",
      "Qwen2.5-0.5B-Instruct-q4f32_1-ctx4k_cs1k-webgpu.wasm",
      "Qwen2-0.5B-Instruct-q4f32_1-ctx32k_cs2k-webgpu.wasm",
      "Qwen2-0.5B-Instruct-q4f32_1-ctx4k_cs1k-webgpu.wasm",
      "Qwen2.5-0.5B-Instruct-q4f32_1-webgpu.wasm",
      "Qwen2-0.5B-Instruct-q4f32_1-webgpu.wasm",
    ];

    // CDN base candidates for binary wasm libs.
    // NOTE: The reported error was for raw.githubusercontent.com + a version folder like v0_2_43.
    // Some environments block raw.githubusercontent.com or that specific version folder may not exist.
    // We probe multiple mirrors + version folder spellings.
    const LIB_CDN_BASES = [
      // jsDelivr (usually the most reliable for browser assets)
      "https://cdn.jsdelivr.net/gh/mlc-ai/binary-mlc-llm-libs@main/web-llm-models/",
      // Raw GitHub (sometimes blocked)
      "https://raw.githubusercontent.com/mlc-ai/binary-mlc-llm-libs/main/web-llm-models/",
    ];

    // Version candidates: normalize v0_2_43 <-> v0.2.43, and prefer the WebLLM import version.
    function normalizeVersionVariants(v) {
      const out = new Set();
      if (!v) return [...out];
      out.add(v);
      out.add(v.replace(/_/g, '.'));
      out.add(v.replace(/\./g, '_'));
      return [...out];
    }

    const importPreferredVersions = ["v0.2.46", "v0_2_46", "v0.2.43", "v0_2_43"]; // include common fallbacks
    const webllmVersions = normalizeVersionVariants(webllm.modelVersion || "");
    const VERSION_FOLDERS = Array.from(new Set([...importPreferredVersions, ...webllmVersions].filter(Boolean)));

    // --------- UI Helpers ---------
    const $ = (id) => document.getElementById(id);
    const $loader = $("loader");
    const $app = $("app");
    const $status = $("status-text");
    const $progress = $("progress");
    const $pct = $("pct");
    const $hint = $("hint");
    const $msgs = $("messages");
    const $input = $("user-input");
    const $btn = $("send-btn");
    const $diag = $("diag");
    const $diagToggle = $("diag-toggle");

    function setHint(text, tone = 'muted') {
      $hint.textContent = text;
      $hint.style.color = tone === 'danger' ? 'var(--danger)' : (tone === 'warn' ? 'var(--warn)' : '#64748b');
    }

    function setStatus(text, tone = 'muted') {
      $status.textContent = text;
      $status.style.color = tone === 'danger' ? 'var(--danger)' : (tone === 'warn' ? 'var(--warn)' : 'var(--muted)');
    }

    function appendMessage(role, text, asMarkdown = true) {
      const div = document.createElement("div");
      div.className = `msg ${role === 'user' ? 'user' : 'bot'}`;
      if (role === 'user') {
        div.textContent = text;
      } else {
        div.innerHTML = asMarkdown ? marked.parse(text) : text;
      }
      $msgs.appendChild(div);
      $msgs.scrollTop = $msgs.scrollHeight;
      return div;
    }

    function showApp() {
      $loader.style.opacity = "0";
      setTimeout(() => {
        $loader.style.display = "none";
        $app.style.opacity = "1";
      }, 500);
    }

    function diagLine(k, v) { return `${k}: ${v}`; }

    function updateDiag(extra = {}) {
      const lines = [];
      lines.push(diagLine('crossOriginIsolated', String(window.crossOriginIsolated)));
      lines.push(diagLine('serviceWorker.controller', String(!!navigator.serviceWorker?.controller)));
      lines.push(diagLine('navigator.gpu', String(!!navigator.gpu)));
      lines.push(diagLine('webllm.modelVersion', String(webllm.modelVersion || '')));
      lines.push(diagLine('VERSION_FOLDERS', VERSION_FOLDERS.join(', ')));
      if (extra.resolved) lines.push(diagLine('resolved model_lib', extra.resolved));
      if (extra.tried) lines.push(diagLine('tried', extra.tried));
      if (extra.error) lines.push(diagLine('lastError', extra.error));
      $diag.textContent = lines.join('\n');
    }

    $diagToggle.addEventListener('click', () => {
      const open = $diag.style.display === 'block';
      $diag.style.display = open ? 'none' : 'block';
      $diagToggle.setAttribute('aria-expanded', open ? 'false' : 'true');
    });

    // --------- Self-tests ---------
    function assert(name, cond) {
      if (!cond) throw new Error(`Self-test failed: ${name}`);
    }

    function runSelfTests() {
      assert('marked loaded', typeof window.marked?.parse === 'function');
      assert('#loader exists', !!$loader);
      assert('#app exists', !!$app);
      assert('#messages exists', !!$msgs);
      assert('#user-input exists', !!$input);
      assert('#send-btn exists', !!$btn);

      // URL/version normalization tests (pure, no network)
      const variants = normalizeVersionVariants('v0_2_43');
      assert('version variants include dotted', variants.includes('v0.2.43'));
      assert('version variants include underscored', variants.includes('v0_2_43'));

      // Ensure we have at least one CDN base and version folder
      assert('LIB_CDN_BASES non-empty', Array.isArray(LIB_CDN_BASES) && LIB_CDN_BASES.length > 0);
      assert('VERSION_FOLDERS non-empty', Array.isArray(VERSION_FOLDERS) && VERSION_FOLDERS.length > 0);

      return true;
    }

    // --------- Network probing ---------
    async function probeExists(url) {
      try {
        // Range GET avoids downloading the full wasm just to test existence.
        const r = await fetch(url, {
          method: 'GET',
          headers: { 'Range': 'bytes=0-0' },
          cache: 'no-store',
          mode: 'cors',
          credentials: 'omit'
        });
        return r.ok || r.status === 206;
      } catch (_) {
        return false;
      }
    }

    async function resolveModelLibURL() {
      const tried = [];

      for (const base of LIB_CDN_BASES) {
        for (const ver of VERSION_FOLDERS) {
          const prefix = base + ver + "/";
          for (const file of MODEL_LIB_FILENAMES) {
            const url = prefix + file;
            tried.push(url);
            if (await probeExists(url)) {
              return { url, tried };
            }
          }
        }
      }

      return { url: null, tried };
    }

    // --------- WebLLM init + chat ---------
    let engine;
    const messages = [{ role: "system", content: "You are Qwen, a helpful and concise AI assistant." }];

    async function initialize() {
      try {
        runSelfTests();
      } catch (e) {
        setStatus(e.message, 'danger');
        setHint('A required dependency failed to load. Check Diagnostics.', 'danger');
        updateDiag({ error: e.message });
        return;
      }

      updateDiag();

      if (!navigator.gpu) {
        setStatus('Error: WebGPU is not supported/enabled in this browser.', 'danger');
        setHint('Use Chrome/Edge with WebGPU enabled. WebLLM requires WebGPU.', 'danger');
        return;
      }

      if (!window.crossOriginIsolated) {
        setStatus('Cross-origin isolation not active (yet).', 'warn');
        setHint('Serve via localhost and reload once so the Service Worker can apply COOP/COEP.', 'warn');
      } else {
        setHint('');
      }

      try {
        setStatus('Resolving model library URL…');
        const resolved = await resolveModelLibURL();

        if (!resolved.url) {
          setStatus('Error: Could not locate the model .wasm library on known mirrors.', 'danger');
          setHint('This environment may block fetching large WASM from public CDNs. Open Diagnostics to see tried URLs.', 'warn');
          updateDiag({ tried: `Tried ${resolved.tried.length} URLs (see below)`, error: 'Cannot fetch model wasm' });
          // Dump tried URLs into diagnostics for quick copy/paste.
          $diag.textContent = ($diag.textContent + "\n\n" + resolved.tried.join("\n")).trim();
          $diag.style.display = 'block';
          $diagToggle.setAttribute('aria-expanded', 'true');
          return;
        }

        updateDiag({ resolved: resolved.url });

        // Always provide appConfig so WebLLM doesn't use a wrong/blocked default lib URL.
        const appConfig = JSON.parse(JSON.stringify(webllm.prebuiltAppConfig ?? { model_list: [] }));
        appConfig.model_list = (appConfig.model_list ?? []).filter(m => m.model_id !== selectedModel);
        appConfig.model_list.push({
          model: MODEL_REPO,
          model_id: selectedModel,
          model_lib: resolved.url,
          vram_required_MB: 900,
          low_resource_required: true,
        });

        setStatus('Starting engine & downloading…');
        engine = await webllm.CreateMLCEngine(selectedModel, {
          appConfig,
          initProgressCallback: (info) => {
            const p = Math.max(0, Math.min(1, Number(info?.progress ?? 0)));
            const pct = Math.floor(p * 100);
            $progress.style.width = pct + '%';
            $pct.textContent = pct + '%';
            const t = String(info?.text ?? '').replace('Fetching', 'Downloading');
            setStatus(t || 'Downloading…');
          }
        });

        showApp();
        appendMessage('assistant', 'Loaded. Ask me anything.');
        $input.focus();

      } catch (err) {
        console.error(err);
        const msg = (err && err.message) ? err.message : String(err);
        setStatus('Error initializing model: ' + msg, 'danger');
        updateDiag({ error: msg });

        if (String(msg).includes('Cannot fetch') || String(msg).includes('.wasm')) {
          setHint('WASM fetch failed (404/CORS/network). Use Diagnostics to see the resolved/attempted URLs and check DevTools → Network for the failing request.', 'warn');
        } else if (!window.crossOriginIsolated) {
          setHint('Likely missing cross-origin isolation. Serve via localhost and reload once.', 'warn');
        } else {
          setHint('Open Diagnostics and DevTools Console/Network to identify the failing URL.', 'warn');
        }
      }
    }

    async function handleSend() {
      const text = $input.value.trim();
      if (!text || !engine) return;

      $input.value = '';
      $input.disabled = true;
      $btn.disabled = true;

      appendMessage('user', text, false);
      messages.push({ role: 'user', content: text });

      const botBubble = appendMessage('assistant', '…', false);
      let fullResponse = '';

      try {
        const chunks = await engine.chat.completions.create({
          messages,
          stream: true,
          temperature: 0.7,
        });

        for await (const chunk of chunks) {
          const content = chunk?.choices?.[0]?.delta?.content || '';
          fullResponse += content;
          botBubble.innerHTML = marked.parse(fullResponse || '…');
          $msgs.scrollTop = $msgs.scrollHeight;
        }

        messages.push({ role: 'assistant', content: fullResponse });

      } catch (err) {
        console.error(err);
        botBubble.textContent = 'Error: ' + ((err && err.message) ? err.message : String(err));
      } finally {
        $input.disabled = false;
        $btn.disabled = false;
        $input.focus();
      }
    }

    $btn.addEventListener('click', handleSend);
    $input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    });

    initialize();
  </script>
</body>
</html>
