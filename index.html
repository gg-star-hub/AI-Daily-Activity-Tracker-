<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI Daily Activity Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js (pie). App falls back to a table if CDN fails). -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
  <style>
    html, body { height: 100%; }
  </style>
</head>
<body class="bg-gray-900 text-white flex flex-col min-h-screen">
  <!-- Header -->
  <header class="bg-gray-800 p-4 text-center text-xl font-bold">
    AI Daily Activity Tracker
  </header>

  <!-- Logs -->
  <main class="flex-1 p-4 overflow-y-auto">
    <div id="log" class="space-y-3" aria-live="polite"></div>

    <!-- Activity Chart Section -->
    <section id="chartSection" class="mt-6 bg-gray-800 rounded-lg p-4">
      <h3 class="text-sm font-semibold mb-3 text-gray-200">Activity Breakdown</h3>
      <div class="flex items-center justify-center">
        <canvas id="activityChart" aria-label="Activity breakdown chart" role="img" style="max-height:300px; width:100%"></canvas>
      </div>
      <div id="chartFallback" class="hidden text-sm mt-3"></div>
      <p id="chartEmpty" class="text-xs text-gray-400 mt-3 hidden">No logs yet. Log some activities to see the chart.</p>
    </section>
  </main>

  <!-- Floating buttons (right) -->
  <div class="fixed bottom-4 right-4 space-y-2 z-40">
    <button id="fabBtn" class="bg-green-600 hover:bg-green-700 p-4 rounded-full shadow text-xl" aria-label="Log activity">‚ûï</button>
    <button id="clearBtn" class="bg-red-600 hover:bg-red-700 p-4 rounded-full shadow" aria-label="Clear logs">üóëÔ∏è</button>
    <button id="manageBtn" class="bg-blue-600 hover:bg-blue-700 p-4 rounded-full shadow" aria-label="Manage activities">‚öôÔ∏è</button>
  </div>

  <!-- Tools FAB (left) -->
  <div class="fixed bottom-4 left-4 z-50">
    <button id="toolsFab" class="bg-gray-700 hover:bg-gray-600 p-4 rounded-full shadow text-xl" aria-label="Open tools panel">‚ò∞</button>

    <!-- Tools Panel -->
    <div id="toolsPanel" class="hidden absolute bottom-16 left-0 w-80 bg-gray-800 border border-gray-700 rounded-xl shadow-xl p-4">
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-semibold text-sm">Tools</h3>
        <button id="closeTools" class="text-gray-300 hover:text-white" aria-label="Close tools">‚úñ</button>
      </div>

      <!-- Search / Filter / Sort -->
      <div class="space-y-2 mb-3">
        <input id="searchInput" class="w-full p-2 rounded text-black" placeholder="Search feedback or activity‚Ä¶" aria-label="Search logs" />
        <select id="filterActivity" class="w-full p-2 rounded text-black" aria-label="Filter by activity">
          <option value="">All activities</option>
        </select>
        <select id="sortSelect" class="w-full p-2 rounded text-black" aria-label="Sort logs">
          <option value="timeDesc">Newest first</option>
          <option value="timeAsc">Oldest first</option>
          <option value="activityAsc">Activity A‚ÜíZ</option>
          <option value="activityDesc">Activity Z‚ÜíA</option>
        </select>
      </div>

      <hr class="border-gray-700 my-3" />

      <!-- Export / Import -->
      <div class="grid grid-cols-2 gap-2 mb-2">
        <button id="exportJsonBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs" aria-label="Export logs as JSON">Export JSON</button>
        <button id="exportCsvBtn"  class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs" aria-label="Export logs as CSV">Export CSV</button>
        <button id="importJsonBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs col-span-2" aria-label="Import logs from JSON">Import</button>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
      </div>

      <!-- AI cache / retry / model links -->
      <div class="grid grid-cols-2 gap-2">
        <button id="retryLoadBtn" class="bg-amber-600 hover:bg-amber-500 px-3 py-2 rounded shadow text-xs" aria-label="Retry AI model load">Retry AI Load</button>
        <button id="clearAICacheBtn" class="bg-amber-700 hover:bg-amber-600 px-3 py-2 rounded shadow text-xs" aria-label="Clear AI cache">Clear AI cache</button>
        <button id="modelLinksBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded shadow text-xs col-span-2" aria-label="Show model links">Model download links</button>
      </div>
    </div>
  </div>

  <!-- Log Modal -->
  <div id="logModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50" role="dialog" aria-modal="true" aria-labelledby="logTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-80">
      <h2 id="logTitle" class="text-lg font-bold mb-3">Log Activity</h2>

      <label class="block text-sm mb-1">Activity</label>
      <select id="activitySelect" class="w-full p-2 text-black rounded mb-3">
        <option value="" disabled selected>Select activity</option>
      </select>

      <div class="flex items-center justify-between mb-3">
        <label class="flex items-center space-x-2 text-sm">
          <input type="checkbox" id="aiToggle" />
          <span>Enable AI Coach</span>
        </label>
        <span id="modelBadge" class="text-xs text-yellow-400"></span>
      </div>

      <label class="block text-sm mb-1">Choose AI Model</label>
      <select id="modelSelect" class="w-full p-2 text-black rounded mb-3">
        <option value="distilgpt2">DistilGPT-2 (82M, ~70‚Äì80MB)</option>
        <option value="smollm135">SmolLM2-135M-Instruct (q4, ~80‚Äì120MB)</option>
        <option value="t5small">T5-small (text2text, ~200‚Äì240MB)</option>
      </select>

      <div id="modelInfo" class="text-xs text-yellow-400 mb-3 hidden"></div>

      <div class="flex gap-2">
        <button id="closeLog" class="w-1/2 bg-gray-700 hover:bg-gray-600 py-2 rounded">Close</button>
        <button id="logBtn" class="w-1/2 bg-green-600 hover:bg-green-700 py-2 rounded">Log</button>
      </div>
    </div>
  </div>

  <!-- Manage Modal -->
  <div id="manageModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50" role="dialog" aria-modal="true" aria-labelledby="manageTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-80">
      <h2 id="manageTitle" class="text-lg font-bold mb-3">Manage Activities</h2>
      <input id="newActivityInput" type="text" placeholder="New activity" class="w-full p-2 text-black rounded mb-2" />
      <button id="addActivityBtn" class="w-full bg-blue-600 hover:bg-blue-700 py-2 rounded mb-4">Add</button>
      <ul id="activityList" class="space-y-1 max-h-40 overflow-y-auto mb-3"></ul>
      <button id="backBtn" class="w-full bg-gray-600 hover:bg-gray-500 py-2 rounded">‚¨Ö Go Back</button>
    </div>
  </div>

  <!-- Model Links Modal -->
  <div id="linksModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50" role="dialog" aria-modal="true" aria-labelledby="linksTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-[28rem] max-w-[90vw]">
      <h2 id="linksTitle" class="text-lg font-bold mb-3">Model download pages</h2>
      <ul class="list-disc list-inside space-y-1 text-sm">
        <li><a class="text-blue-300 hover:underline" target="_blank" rel="noopener" href="https://huggingface.co/Xenova/distilgpt2">Xenova/distilgpt2</a></li>
        <li><a class="text-blue-300 hover:underline" target="_blank" rel="noopener" href="https://huggingface.co/HuggingFaceTB/SmolLM2-135M-Instruct">HuggingFaceTB/SmolLM2-135M-Instruct</a></li>
        <li><a class="text-blue-300 hover:underline" target="_blank" rel="noopener" href="https://huggingface.co/Xenova/t5-small">Xenova/t5-small</a></li>
      </ul>
      <div class="text-[11px] text-gray-400 mt-2">Tip: first load caches the model locally (IndexedDB + Cache Storage). If the browser struggles, use the Cancel button below and try a smaller model.</div>
      <div class="flex gap-2 mt-4">
        <button id="closeLinks" class="w-1/2 bg-gray-700 hover:bg-gray-600 py-2 rounded">Close</button>
        <button id="prefetchBtn" class="w-1/2 bg-amber-600 hover:bg-amber-500 py-2 rounded">Prefetch selected model</button>
      </div>
    </div>
  </div>

  <!-- Spinner / progress -->
  <div id="spinner"
       class="hidden fixed bottom-16 left-1/2 -translate-x-1/2 bg-yellow-500 text-black px-3 py-2 rounded shadow text-sm z-50"
       role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-live="polite">
    <div class="flex items-center justify-between gap-4">
      <div>
        <div id="spinnerText" class="font-semibold">Downloading AI Coach‚Ä¶</div>
        <div class="w-52 bg-gray-300 h-2 mt-1 rounded">
          <div id="progressBar" class="bg-green-700 h-2 rounded" style="width:0%"></div>
        </div>
        <div id="spinnerSub" class="text-[11px] mt-1 opacity-80"></div>
      </div>
      <button id="cancelDownloadBtn" class="bg-black/70 text-white px-3 py-1 rounded">Cancel</button>
    </div>
  </div>

  <!-- Footer/version -->
  <footer class="text-xs text-gray-400 absolute bottom-1 left-2">Testversion 0.37</footer>

  <script type="module">
    // Elements
    const logDiv = document.getElementById('log');
    const fabBtn = document.getElementById('fabBtn');
    const clearBtn = document.getElementById('clearBtn');
    const manageBtn = document.getElementById('manageBtn');
    const logModal = document.getElementById('logModal');
    const manageModal = document.getElementById('manageModal');
    const closeLog = document.getElementById('closeLog');
    const backBtn = document.getElementById('backBtn');
    const logBtn = document.getElementById('logBtn');
    const activitySelect = document.getElementById('activitySelect');
    const aiToggle = document.getElementById('aiToggle');
    const modelSelect = document.getElementById('modelSelect');
    const modelBadge = document.getElementById('modelBadge');
    const modelInfo = document.getElementById('modelInfo');
    const newActivityInput = document.getElementById('newActivityInput');
    const addActivityBtn = document.getElementById('addActivityBtn');
    const activityList = document.getElementById('activityList');
    const spinner = document.getElementById('spinner');
    const spinnerText = document.getElementById('spinnerText');
    const spinnerSub = document.getElementById('spinnerSub');
    const progressBar = document.getElementById('progressBar');
    const cancelDownloadBtn = document.getElementById('cancelDownloadBtn');
    const chartSection = document.getElementById('chartSection');
    const chartEmpty = document.getElementById('chartEmpty');
    const chartCanvas = document.getElementById('activityChart');
    const chartFallback = document.getElementById('chartFallback');

    // Tools panel elements
    const toolsFab = document.getElementById('toolsFab');
    const toolsPanel = document.getElementById('toolsPanel');
    const closeTools = document.getElementById('closeTools');
    const modelLinksBtn = document.getElementById('modelLinksBtn');

    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const exportCsvBtn  = document.getElementById('exportCsvBtn');
    const importJsonBtn = document.getElementById('importJsonBtn');
    const importFile    = document.getElementById('importFile');
    const retryLoadBtn  = document.getElementById('retryLoadBtn');
    const clearAICacheBtn = document.getElementById('clearAICacheBtn');

    // Search/filters now live in Tools Panel
    const searchInput   = document.getElementById('searchInput');
    const filterActivity = document.getElementById('filterActivity');
    const sortSelect    = document.getElementById('sortSelect');

    // Links modal elements
    const linksModal = document.getElementById('linksModal');
    const closeLinks = document.getElementById('closeLinks');
    const prefetchBtn = document.getElementById('prefetchBtn');

    // Data
    const STORAGE_KEYS = { ACTIVITIES: 'activityList', LOGS: 'activityLogs' };
    let activities = JSON.parse(localStorage.getItem(STORAGE_KEYS.ACTIVITIES) || '[]');
    if (!activities.length) activities = ['Eat','Sleep','Work','Exercise','Study','Commute','Socialize','Relax','Shop','Cook'];
    let logs = JSON.parse(localStorage.getItem(STORAGE_KEYS.LOGS) || '[]');

    // AI state
    let generator = null;
    let activeModelKey = 'distilgpt2'; // 'distilgpt2' | 'smollm42' | 't5tiny'
    let activeModelId = null;          // HF repo id
    let activeTask = null;             // 'text-generation' | 'text2text-generation'
    const TIMEOUT_MS = 12 * 60 * 1000; // 12 minutes hard cap
    const BASE_GEN_TIMEOUT = 14000;    // 14s inference
    let logBusy = false;
    let cancelFlag = false;            // soft-cancel for downloads

    // Model config (MobileBERT removed; added SmolLM-42M + T5-efficient-tiny)
    const MODELS = {
      distilgpt2: {
        id: 'Xenova/distilgpt2',
        task: 'text-generation',
        note: '~70‚Äì80MB first load',
        badge: 'DistilGPT-2',
        opts: {}
      },
      smollm135: {
        id: 'HuggingFaceTB/SmolLM2-135M-Instruct',
        task: 'text-generation',
        note: 'ONNX q4 ~80‚Äì120MB',
        badge: 'SmolLM2-135M (q4)',
        opts: { dtype: 'q4' }
      },
      t5small: {
        id: 'Xenova/t5-small',
        task: 'text2text-generation',
        note: '~200‚Äì240MB first load',
        badge: 'T5-small',
        opts: {}
      }
    };

    // ---- Chart color palette (cycles if more slices than colors) ----
    const PALETTE = ['#10b981', '#3b82f6', '#ef4444', '#f59e0b'];

    // Utils
    const sanitize = (s) => String(s).replace(/[<>"'&]/g, c => ({'<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#x27;','&':'&amp;'}[c]));
    const limitSentences = (t, n=4) => t.split(/(?<=[.!?])\s+/).slice(0, n).join(' ');
    function debounce(fn, ms=300){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }
    function warnIfNearLimit() {
      try {
        const used = Object.keys(localStorage).reduce((sum, k) => sum + (localStorage.getItem(k)?.length || 0), 0);
        if (used > 4.5e6) {
          const approxMB = (used/1e6).toFixed(2);
          alert(`‚ö†Ô∏è Local storage almost full (~${approxMB}MB). Older logs may be truncated.`);
        }
      } catch {}
    }
    function safeSave(key, val) {
      warnIfNearLimit();
      try { localStorage.setItem(key, JSON.stringify(val)); }
      catch {
        if (key === STORAGE_KEYS.LOGS && logs.length > 10) {
          logs = logs.slice(-10);
          localStorage.setItem(STORAGE_KEYS.LOGS, JSON.stringify(logs));
          alert('‚ö†Ô∏è Storage full. Kept last 10 logs.');
        } else {
          alert('‚ö†Ô∏è Storage full. Data not saved.');
        }
      }
    }

    // Fallback phrases (guaranteed present)
    function ruleFeedback(a) {
      const m = {
        Eat:'üçΩÔ∏è Good to stay nourished!', Sleep:'üò¥ Rest is essential.', Work:'üíº Keep focused!',
        Exercise:'üèÉ Great energy boost.', Study:'üìö Knowledge is power.', Commute:'üöå Time well spent traveling.',
        Socialize:'ü§ù Stay connected.', Relax:'üßò Calm and balanced.', Shop:'üõí Don‚Äôt overspend!', Cook:'üë©‚Äçüç≥ Healthy eating starts here.'
      };
      return m[a] || 'Great job ‚Äî keep the momentum going!';
    }

    // Activity counts / chart
    let activityChart = null;
    function getActivityCounts(list = logs) {
      const counts = {};
      for (const l of list) counts[l.activity] = (counts[l.activity] || 0) + 1;
      return counts;
    }
    function renderCountsTable(counts) {
      const total = Object.values(counts).reduce((a,b)=>a+b,0);
      const rows = Object.entries(counts)
        .sort((a,b)=>b[1]-a[1])
        .map(([k,v]) => `<tr><td class="pr-4 py-1">${sanitize(k)}</td><td class="text-right py-1">${v}</td><td class="text-right text-gray-300 py-1">${((v/total)*100).toFixed(1)}%</td></tr>`)
        .join('');
      chartFallback.innerHTML = `
        <div class="rounded border border-gray-700 p-3">
          <div class="text-xs text-gray-400 mb-2">Chart unavailable ‚Äî showing table.</div>
          <table class="text-sm w-full"><tbody>${rows}</tbody></table>
        </div>`;
    }
    function updateChart(filtered = null) {
      const list = filtered || logs;
      const counts = getActivityCounts(list);
      const labels = Object.keys(counts);
      const data = Object.values(counts);

      const isEmpty = data.length === 0;
      chartSection.classList.toggle('hidden', isEmpty);
      chartEmpty.classList.toggle('hidden', !isEmpty);
      if (isEmpty) return;

      // Colors from palette (cycle if needed)
      const colors = labels.map((_, i) => PALETTE[i % PALETTE.length]);

      if (!window.Chart) {
        chartCanvas.parentElement.classList.add('hidden');
        chartFallback.classList.remove('hidden');
        renderCountsTable(counts);
        return;
      } else {
        chartCanvas.parentElement.classList.remove('hidden');
        chartFallback.classList.add('hidden');
      }

      const ctx = chartCanvas.getContext('2d');
      if (activityChart) {
        activityChart.data.labels = labels;
        activityChart.data.datasets[0].data = data;
        activityChart.data.datasets[0].backgroundColor = colors;
        activityChart.update();
        return;
      }
      activityChart = new Chart(ctx, {
        type: 'doughnut',
        data: { labels, datasets: [{ data, backgroundColor: colors, borderWidth: 0 }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom', labels: { color: '#e5e7eb' } } } }
      });
    }

    // Filtering / Sorting
    function applyFilterAndSort() {
      const q = searchInput.value.trim().toLowerCase();
      const fa = filterActivity.value;
      const sort = sortSelect.value;

      let view = logs.slice();
      if (fa) view = view.filter(l => l.activity === fa);
      if (q) view = view.filter(l =>
        l.activity.toLowerCase().includes(q) || (l.feedback||'').toLowerCase().includes(q)
      );

      view.sort((a,b) => {
        if (sort === 'timeAsc') return new Date(a.time) - new Date(b.time);
        if (sort === 'timeDesc') return new Date(b.time) - new Date(a.time);
        if (sort === 'activityAsc') return a.activity.localeCompare(b.activity);
        if (sort === 'activityDesc') return b.activity.localeCompare(a.activity);
        return 0;
      });

      renderLogs(view);
      updateChart(view);
    }

    // Renders
    function renderActivities() {
      // Activity select (modal)
      const current = activitySelect.value;
      activitySelect.innerHTML = '<option value="" disabled>Select activity</option>';
      activities.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a; opt.textContent = a;
        activitySelect.appendChild(opt);
      });
      if (current && activities.includes(current)) activitySelect.value = current;
      else activitySelect.selectedIndex = 0;

      // Filter dropdown (in tools panel)
      filterActivity.innerHTML = '<option value="">All activities</option>';
      activities.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a; opt.textContent = a;
        filterActivity.appendChild(opt);
      });

      // Manage list
      activityList.innerHTML = '';
      activities.forEach((a,i) => {
        const li = document.createElement('li');
        li.className = 'flex justify-between items-center bg-gray-700 rounded px-2 py-1';
        li.innerHTML = `<span>${sanitize(a)}</span>
                        <button class="text-red-300 hover:text-red-200" aria-label="Delete activity ${sanitize(a)}" tabindex="0">‚úñ</button>`;
        const delBtn = li.querySelector('button');
        delBtn.onclick = () => {
          if (!confirm(`Delete "${a}"?`)) return;
          activities.splice(i,1);
          safeSave(STORAGE_KEYS.ACTIVITIES, activities);
          renderActivities();
          applyFilterAndSort();
        };
        delBtn.onkeydown = (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); delBtn.click(); }
        };
        activityList.appendChild(li);
      });
    }

    function renderLogs(list = logs) {
      logDiv.innerHTML = '';
      list.forEach((l) => {
        const isThinking = l.status === 'thinking';
        const isFail = l.status === 'fail';
        const border = isThinking ? 'border-yellow-400' : isFail ? 'border-red-400' : 'border-green-400';
        const titleC = isThinking ? 'text-yellow-300' : isFail ? 'text-red-300' : 'text-green-300';
        const card = document.createElement('div');
        card.className = `bg-gray-800 p-3 rounded border-l-4 ${border}`;
        card.innerHTML = `
          <div class="flex justify-between gap-3">
            <div>
              <div class="font-semibold">${sanitize(l.activity)}</div>
              <div class="text-xs text-gray-400">${l.time}</div>
              <div class="text-[11px] text-yellow-400 mt-0.5">AI Model: ${sanitize(l.model || 'N/A')}</div>
            </div>
            <div class="flex items-start gap-2">
              <button class="text-gray-300 hover:text-white" title="Copy feedback" aria-label="Copy feedback">üìã</button>
              <button class="text-gray-300 hover:text-white" title="Share" aria-label="Share log">üì§</button>
              <button class="text-red-400 hover:text-red-300" title="Delete log" aria-label="Delete log">üóëÔ∏è</button>
            </div>
          </div>
          <div class="${titleC} mt-2">${sanitize(l.feedback || '')}</div>
        `;
        const [copyBtn, shareBtn, delBtn] = card.querySelectorAll('button');

        copyBtn.onclick = async () => {
          try { await navigator.clipboard.writeText(l.feedback || ''); alert('Copied to clipboard.'); }
          catch { alert('Could not copy.'); }
        };
        shareBtn.onclick = async () => {
          const text = `Activity: ${l.activity}\nTime: ${l.time}\nFeedback: ${l.feedback || ''}`;
          if (navigator.share) {
            try { await navigator.share({ title: 'My Activity Log', text }); } catch {}
          } else {
            try { await navigator.clipboard.writeText(text); alert('Copied (no native share on this device).'); }
            catch { alert('Could not share or copy.'); }
          }
        };
        delBtn.onclick = () => {
          if (!confirm('Delete this log?')) return;
          const ix = logs.indexOf(l);
          if (ix >= 0) logs.splice(ix, 1);
          safeSave(STORAGE_KEYS.LOGS, logs);
          applyFilterAndSort();
        };
        logDiv.appendChild(card);
      });
    }

    // Model selection -> config
    function applyModelSelection() {
      const key = modelSelect.value;
      activeModelKey = key;
      const cfg = MODELS[key];
      activeModelId = cfg.id;
      activeTask   = cfg.task;
      modelBadge.textContent = cfg.badge;
      spinnerSub.textContent = `${cfg.note}, cached after first load`;
    }
    applyModelSelection();
    modelSelect.onchange = applyModelSelection;

    // Focus trap for modals
    function trapFocus(modal) {
      const focusable = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      if (!focusable.length) return () => {};
      const first = focusable[0], last = focusable[focusable.length - 1];
      function handler(e) {
        if (e.key !== 'Tab') return;
        if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
        else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
      }
      modal.addEventListener('keydown', handler);
      first.focus();
      return () => modal.removeEventListener('keydown', handler);
    }
    let untrap = () => {};

    // Transformers.js loader
    async function importTransformers() {
      return await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.2');
    }

    // Download cancel (soft)
    cancelDownloadBtn.onclick = () => { cancelFlag = true; spinner.classList.add('hidden'); };

    async function loadModel() {
      if (!navigator.onLine) { alert('‚ö†Ô∏è Offline. AI Coach needs internet.'); aiToggle.checked = false; return null; }
      if (!window.WebAssembly) { alert('‚ö†Ô∏è Browser lacks WebAssembly. Use Chrome/Firefox/Edge.'); aiToggle.checked = false; return null; }

      const { pipeline } = await importTransformers();
      const attempts = [0, 2000, 5000]; // backoff (ms)
      cancelFlag = false;

      for (let i = 0; i < attempts.length; i++) {
        try {
          spinner.classList.remove('hidden');
          spinnerText.textContent = `Downloading ${activeModelId}‚Ä¶`;
          progressBar.style.width = '0%';
          spinner.setAttribute('aria-valuenow', '0');

          const cfg = MODELS[activeModelKey];
          const opts = {
            progress_callback: (p) => {
              if (cancelFlag) return; // UI soft-cancel
              if (p && p.loaded && p.total) {
                const pct = Math.floor((p.loaded / p.total) * 100);
                progressBar.style.width = pct + '%';
                spinnerText.textContent = `Downloading‚Ä¶ ${pct}%`;
                spinnerSub.textContent = `${(p.loaded/1e6).toFixed(1)}MB / ${(p.total/1e6).toFixed(1)}MB`;
                spinner.setAttribute('aria-valuenow', String(pct));
              }
            }
          };
          // Attempt 1 uses WebGPU if available; later attempts force CPU/wasm to reduce crashes
          opts.device = (i === 0 && navigator.gpu) ? 'webgpu' : 'cpu';
          Object.assign(opts, cfg.opts);

          const gen = await Promise.race([
            pipeline(cfg.task, cfg.id, opts),
            new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), TIMEOUT_MS))
          ]);

          if (cancelFlag) { cancelFlag = false; return null; }

          spinnerText.textContent = '‚úÖ AI Coach ready (cached)';
          setTimeout(() => spinner.classList.add('hidden'), 300);
          return gen;
        } catch (e) {
          console.warn(`Model load attempt ${i+1} failed:`, e.message);
          await new Promise(r => setTimeout(r, attempts[i]));
        } finally {
          setTimeout(() => spinner.classList.add('hidden'), 300);
        }
      }
      alert('‚ö†Ô∏è Failed to load AI Coach after multiple attempts. Using rule-based feedback.');
      aiToggle.checked = false;
      return null;
    }

    // Prompt builders
    function buildPrompt(activity) {
      const ask = `Give 2‚Äì4 short, specific, encouraging sentences about: "${activity}". Focus on momentum, next tiny step, and consistency.`;
      if (activeTask === 'text2text-generation') return ask;
      if (activeTask === 'text-generation')     return `You are a concise wellbeing coach. ${ask}`;
      return '';
    }

    async function aiCoachFeedback(activity) {
      const input = buildPrompt(activity);
      const cores = navigator.hardwareConcurrency || 4;
      const GEN_MS = Math.min(28000, Math.max(10000, cores < 4 ? 18000 : BASE_GEN_TIMEOUT));
      try {
        const out = await Promise.race([
          generator(input, { max_new_tokens: 64 }),
          new Promise((_, rej) => setTimeout(() => rej(new Error('AI timeout')), GEN_MS))
        ]);
        let txt = out?.[0]?.generated_text || '';
        if (txt.startsWith(input)) txt = txt.slice(input.length);
        return limitSentences(txt.trim(), 4) || 'Keep it up!';
      } catch (e) {
        console.error('AI feedback fail:', e);
        return `‚ö†Ô∏è AI Coach error (${e.message}). ${ruleFeedback(activity)}`;
      }
    }

    // Export / Import
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      URL.revokeObjectURL(url); a.remove();
    }
    exportJsonBtn.onclick = () => {
      const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json;charset=utf-8' });
      downloadBlob(blob, 'activity_logs.json');
    };
    exportCsvBtn.onclick = () => {
      const rows = [['Time','Activity','Model','Status','Feedback'], ...logs.map(l => [l.time, l.activity, l.model||'', l.status||'', l.feedback||''])];
      const csv = '\uFEFF' + rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\r\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      downloadBlob(blob, 'activity_logs.csv');
    };
    importJsonBtn.onclick = () => importFile.click();
    importFile.onchange = async () => {
      const f = importFile.files[0]; if (!f) return;
      try {
        const text = await f.text();
        const data = JSON.parse(text);
        if (!Array.isArray(data)) throw new Error('Invalid file format.');
        const mode = confirm('Replace existing logs? (OK = Replace, Cancel = Merge)') ? 'replace' : 'merge';
        if (mode === 'replace') logs = data;
        else logs = logs.concat(data);
        safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();
        alert('Import complete.');
      } catch (e) { alert('Import failed: ' + e.message); }
      importFile.value = '';
    };

    // AI Cache clear (best effort)
    clearAICacheBtn.onclick = async () => {
      let cleared = false;
      try {
        if ('caches' in window) {
          const names = await caches.keys();
          for (const n of names) {
            if (/transformers|huggingface|hf|onnx|model/i.test(n)) {
              await caches.delete(n); cleared = true;
            }
          }
        }
      } catch {}
      try {
        if (indexedDB && indexedDB.databases) {
          const dbs = await indexedDB.databases();
          for (const db of dbs) {
            if (db.name && /transformers|huggingface|hf|onnx|model/i.test(db.name)) {
              indexedDB.deleteDatabase(db.name); cleared = true;
            }
          }
        }
      } catch {}
      generator = null;
      alert((cleared ? '‚úÖ' : '‚ÑπÔ∏è') + ' AI cache cleared (best effort). Models will re-download when needed.');
    };

    // Retry load
    retryLoadBtn.onclick = async () => {
      if (!aiToggle.checked) aiToggle.checked = true;
      generator = await loadModel();
      if (generator) {
        const cfg = MODELS[activeModelKey];
        modelInfo.textContent = `Active: ${cfg.badge}`;
        modelInfo.classList.remove('hidden');
      }
    };

    // Tools Panel interactions
    toolsFab.onclick = (e) => { e.stopPropagation(); toolsPanel.classList.toggle('hidden'); };
    closeTools.onclick = () => toolsPanel.classList.add('hidden');
    window.addEventListener('click', (e) => { if (!toolsPanel.contains(e.target) && e.target !== toolsFab) toolsPanel.classList.add('hidden'); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') toolsPanel.classList.add('hidden'); });

    // Model Links modal
    modelLinksBtn.onclick = () => { linksModal.classList.remove('hidden'); trapFocus(linksModal); };
    closeLinks.onclick = () => { linksModal.classList.add('hidden'); untrap(); };
    prefetchBtn.onclick = async () => {
      // open spinner + try to fetch model artifacts for the selected model
      if (!aiToggle.checked) aiToggle.checked = true; // will show spinner during load
      generator = await loadModel();
      if (generator) {
        const cfg = MODELS[activeModelKey];
        modelInfo.textContent = `Active: ${cfg.badge}`;
        modelInfo.classList.remove('hidden');
        linksModal.classList.add('hidden');
        untrap();
      }
    };

    // Events: open/close modals
    const openLog = () => { logModal.classList.remove('hidden'); untrap = trapFocus(logModal); };
    fabBtn.onclick = openLog;
    manageBtn.onclick = () => { manageModal.classList.remove('hidden'); untrap = trapFocus(manageModal); };
    closeLog.onclick = () => { logModal.classList.add('hidden'); untrap(); };
    backBtn.onclick = () => { manageModal.classList.add('hidden'); untrap(); };

    // Close on ESC / outside (modals)
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') { logModal.classList.add('hidden'); manageModal.classList.add('hidden'); linksModal.classList.add('hidden'); untrap(); }
    });
    window.addEventListener('click', (e) => {
      if (e.target === logModal) { logModal.classList.add('hidden'); untrap(); }
      if (e.target === manageModal) { manageModal.classList.add('hidden'); untrap(); }
      if (e.target === linksModal) { linksModal.classList.add('hidden'); untrap(); }
    });

    // Clear logs
    clearBtn.onclick = () => {
      if (confirm('Clear all logs?')) {
        logs = [];
        safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();
      }
    };

    // Add activity (debounced)
    addActivityBtn.onclick = debounce(() => {
      const val = newActivityInput.value.trim();
      if (!val) { alert('Enter activity.'); return; }
      if (activities.includes(val)) { alert('Activity exists.'); return; }
      activities.push(val);
      safeSave(STORAGE_KEYS.ACTIVITIES, activities);
      newActivityInput.value = '';
      renderActivities();
      applyFilterAndSort();
    }, 250);

    // AI toggle -> lazy load model
    aiToggle.onchange = async () => {
      if (!aiToggle.checked) return;
      if (!generator) generator = await loadModel();
      if (generator) {
        const cfg = MODELS[activeModelKey];
        modelInfo.textContent = `Active: ${cfg.badge}`;
        modelInfo.classList.remove('hidden');
      }
    };

    // Log flow with correct fallbacks
    logBtn.onclick = async () => {
      if (logBusy) return;
      logBusy = true;
      try {
        const act = activitySelect.value;
        if (!act) { alert('Please select an activity.'); return; }

        const aiOn = aiToggle.checked;

        // Rule-based path
        if (!aiOn || !generator) {
          const entry = {
            activity: act,
            time: new Date().toLocaleString(),
            model: aiOn && !generator ? 'AI unavailable' : 'N/A',
            feedback: aiOn && !generator ? `‚ö†Ô∏è AI Coach unavailable. ${ruleFeedback(act)}` : ruleFeedback(act),
            status: aiOn && !generator ? 'fail' : 'done'
          };
          logs.push(entry);
          safeSave(STORAGE_KEYS.LOGS, logs);
          applyFilterAndSort();
          logModal.classList.add('hidden');
          return;
        }

        // AI path
        const entry = {
          activity: act,
          time: new Date().toLocaleString(),
          model: MODELS[activeModelKey].badge,
          feedback: 'ü§ñ AI Coach is thinking‚Ä¶',
          status: 'thinking'
        };
        logs.push(entry);
        safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();

        try {
          const feedback = await aiCoachFeedback(act);
          entry.feedback = feedback;
          entry.status = feedback.startsWith('‚ö†Ô∏è') ? 'fail' : 'done';
        } catch (e) {
          entry.feedback = `‚ö†Ô∏è AI Coach error. ${ruleFeedback(act)}`;
          entry.status = 'fail';
        }

        safeSave(STORAGE_KEYS.LOGS, logs);
        applyFilterAndSort();
        logModal.classList.add('hidden');
      } finally {
        logBusy = false;
      }
    };

    // Filters/sort handlers (in Tools Panel)
    searchInput.oninput = debounce(applyFilterAndSort, 150);
    filterActivity.onchange = applyFilterAndSort;
    sortSelect.onchange = applyFilterAndSort;

    // Init
    function init() {
      renderActivities();
      applyFilterAndSort();
    }
    init();
  </script>
</body>
</html>
