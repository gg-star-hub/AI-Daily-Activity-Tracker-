<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI Daily Activity Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js for the pie chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
</head>
<body class="bg-gray-900 text-white flex flex-col min-h-screen">
  <!-- Header -->
  <header class="bg-gray-800 p-4 text-center text-xl font-bold">
    AI Daily Activity Tracker
  </header>

  <!-- Toolbar (exports) -->
  <div class="flex gap-2 p-3 bg-gray-900 sticky top-0 z-10">
    <button id="exportJsonBtn" class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded text-sm">Export JSON</button>
    <button id="exportCsvBtn"  class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded text-sm">Export CSV</button>
  </div>

  <!-- Chart Card -->
  <section id="chartCard" class="px-4 hidden">
    <div class="bg-gray-800 p-4 rounded">
      <div class="flex items-center justify-between mb-2">
        <h3 class="font-semibold">Activity Breakdown</h3>
        <span class="text-xs text-gray-300">share of total logs</span>
      </div>
      <canvas id="activityPie" height="220" aria-label="Activity pie chart" role="img"></canvas>
    </div>
  </section>

  <!-- Logs -->
  <main class="flex-1 p-4 overflow-y-auto">
    <div id="log" class="space-y-3" aria-live="polite"></div>
  </main>

  <!-- Floating buttons -->
  <div class="fixed bottom-4 right-4 space-y-2">
    <button id="fabBtn" class="bg-green-600 hover:bg-green-700 p-4 rounded-full shadow text-xl" aria-label="Log activity">‚ûï</button>
    <button id="clearBtn" class="bg-red-600 hover:bg-red-700 p-4 rounded-full shadow" aria-label="Clear logs">üóëÔ∏è</button>
    <button id="manageBtn" class="bg-blue-600 hover:bg-blue-700 p-4 rounded-full shadow" aria-label="Manage activities">‚öôÔ∏è</button>
  </div>

  <!-- Log Modal -->
  <div id="logModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center" role="dialog" aria-modal="true" aria-labelledby="logTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-80">
      <h2 id="logTitle" class="text-lg font-bold mb-3">Log Activity</h2>

      <label class="block text-sm mb-1">Activity</label>
      <select id="activitySelect" class="w-full p-2 text-black rounded mb-3">
        <option value="" disabled selected>Select activity</option>
      </select>

      <div class="flex items-center justify-between mb-3">
        <label class="flex items-center space-x-2 text-sm">
          <input type="checkbox" id="aiToggle" />
          <span>Enable AI Coach</span>
        </label>
        <span id="modelBadge" class="text-xs text-yellow-400"></span>
      </div>

      <label class="block text-sm mb-1">Choose AI Model</label>
      <select id="modelSelect" class="w-full p-2 text-black rounded mb-3">
        <option value="distilgpt2">DistilGPT-2 (82M, ~70‚Äì80MB)</option>
        <option value="smollm2">SmolLM2-135M-Instruct (quantized ~175MB)</option>
        <option value="t5">T5-small (60M, ~200‚Äì240MB)</option>
      </select>

      <div id="modelInfo" class="text-xs text-yellow-400 mb-3 hidden"></div>

      <div class="flex gap-2">
        <button id="closeLog" class="w-1/2 bg-gray-700 hover:bg-gray-600 py-2 rounded">Close</button>
        <button id="logBtn" class="w-1/2 bg-green-600 hover:bg-green-700 py-2 rounded">Log</button>
      </div>
    </div>
  </div>

  <!-- Manage Modal -->
  <div id="manageModal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center" role="dialog" aria-modal="true" aria-labelledby="manageTitle">
    <div class="bg-gray-800 p-6 rounded-lg w-80">
      <h2 id="manageTitle" class="text-lg font-bold mb-3">Manage Activities</h2>
      <input id="newActivityInput" type="text" placeholder="New activity" class="w-full p-2 text-black rounded mb-2" />
      <button id="addActivityBtn" class="w-full bg-blue-600 hover:bg-blue-700 py-2 rounded mb-4">Add</button>
      <ul id="activityList" class="space-y-1 max-h-40 overflow-y-auto mb-3"></ul>
      <button id="backBtn" class="w-full bg-gray-600 hover:bg-gray-500 py-2 rounded">‚¨Ö Go Back</button>
    </div>
  </div>

  <!-- Spinner / progress -->
  <div id="spinner"
       class="hidden fixed bottom-16 left-1/2 -translate-x-1/2 bg-yellow-500 text-black px-3 py-2 rounded shadow text-sm"
       role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-live="polite">
    <div id="spinnerText" class="font-semibold">Downloading AI Coach‚Ä¶</div>
    <div class="w-52 bg-gray-300 h-2 mt-1 rounded">
      <div id="progressBar" class="bg-green-700 h-2 rounded" style="width:0%"></div>
    </div>
    <div id="spinnerSub" class="text-[11px] mt-1 opacity-80"></div>
  </div>

  <!-- Footer/version -->
  <footer class="text-xs text-gray-400 absolute bottom-1 left-2">Testversion 0.31</footer>

  <script type="module">
    // Elements
    const logDiv = document.getElementById('log');
    const exportJsonBtn = document.getElementById('exportJsonBtn');
    const exportCsvBtn  = document.getElementById('exportCsvBtn');
    const chartCard = document.getElementById('chartCard');
    const fabBtn = document.getElementById('fabBtn');
    const clearBtn = document.getElementById('clearBtn');
    const manageBtn = document.getElementById('manageBtn');
    const logModal = document.getElementById('logModal');
    const manageModal = document.getElementById('manageModal');
    const closeLog = document.getElementById('closeLog');
    const backBtn = document.getElementById('backBtn');
    const logBtn = document.getElementById('logBtn');
    const activitySelect = document.getElementById('activitySelect');
    const aiToggle = document.getElementById('aiToggle');
    const modelSelect = document.getElementById('modelSelect');
    const modelBadge = document.getElementById('modelBadge');
    const modelInfo = document.getElementById('modelInfo');
    const newActivityInput = document.getElementById('newActivityInput');
    const addActivityBtn = document.getElementById('addActivityBtn');
    const activityList = document.getElementById('activityList');
    const spinner = document.getElementById('spinner');
    const spinnerText = document.getElementById('spinnerText');
    const spinnerSub = document.getElementById('spinnerSub');
    const progressBar = document.getElementById('progressBar');
    const activityPieCanvas = document.getElementById('activityPie');

    // Data
    const STORAGE_KEYS = { ACTIVITIES: 'activityList', LOGS: 'activityLogs' };
    let activities = JSON.parse(localStorage.getItem(STORAGE_KEYS.ACTIVITIES) || '[]');
    if (!activities.length) activities = ['Eat','Sleep','Work','Exercise','Study','Commute','Socialize','Relax','Shop','Cook'];
    let logs = JSON.parse(localStorage.getItem(STORAGE_KEYS.LOGS) || '[]');

    // AI state
    let generator = null;
    let activeModelKey = 'distilgpt2'; // 'distilgpt2' | 'smollm2' | 't5'
    let activeModelId = null;          // HF repo id
    let activeTask = null;             // 'text-generation' | 'text2text-generation'
    const TIMEOUT_MS = 1500000;        // 25 minutes (5√ó previous 5 min)
    const BASE_GEN_TIMEOUT = 15000;    // base 15s generation
    let logBusy = false;

    // Chart
    let pieChart = null;

    // Model config
    const MODELS = {
      distilgpt2: {
        id: 'Xenova/distilgpt2',
        task: 'text-generation',
        note: '~70‚Äì80MB first load',
        badge: 'DistilGPT-2',
        opts: {}
      },
      smollm2: {
        id: 'HuggingFaceTB/SmolLM2-135M-Instruct',
        task: 'text-generation',
        note: 'quantized ONNX ~175MB (bnb4)',
        badge: 'SmolLM2-135M (quantized)',
        opts: { dtype: 'bnb4' } // request quantized weights if available
      },
      t5: {
        id: 'Xenova/t5-small',
        task: 'text2text-generation',
        note: '~200‚Äì240MB first load',
        badge: 'T5-small',
        opts: {}
      }
    };

    // Utils
    const sanitize = (s) => String(s).replace(/[<>"'&]/g, c => ({'<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#x27;','&':'&amp;'}[c]));
    const limitSentences = (t, n=4) => t.split(/(?<=[.!?])\s+/).slice(0, n).join(' ');
    function debounce(fn, ms=300){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }
    function warnIfNearLimit() {
      try {
        const used = Object.keys(localStorage).reduce((sum, k) => sum + (localStorage.getItem(k)?.length || 0), 0);
        if (used > 4.5e6) {
          const approxMB = (used/1e6).toFixed(2);
          alert(`‚ö†Ô∏è Local storage almost full (~${approxMB}MB). Older logs may be truncated.`);
        }
      } catch {}
    }
    function safeSave(key, val) {
      warnIfNearLimit();
      try { localStorage.setItem(key, JSON.stringify(val)); }
      catch {
        if (key === STORAGE_KEYS.LOGS && logs.length > 10) {
          logs = logs.slice(-10);
          localStorage.setItem(STORAGE_KEYS.LOGS, JSON.stringify(logs));
          alert('‚ö†Ô∏è Storage full. Kept last 10 logs.');
        } else {
          alert('‚ö†Ô∏è Storage full. Data not saved.');
        }
      }
    }
    function download(name, mime, data) {
      const blob = new Blob([data], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = name;
      document.body.appendChild(a); a.click();
      a.remove(); URL.revokeObjectURL(url);
    }
    function toCSV(rows) {
      const esc = (v) => `"${String(v ?? '').replace(/"/g,'""')}"`;
      const header = ['time','activity','model','feedback','status'];
      const body = rows.map(r => [r.time, r.activity, r.model ?? 'N/A', r.feedback ?? '', r.status ?? ''].map(esc).join(','));
      return '\uFEFF' + [header.join(','), ...body].join('\n'); // BOM for UTF-8/Excel
    }

    // Exports
    exportJsonBtn.onclick = () => {
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      download(`activity_logs_${ts}.json`, 'application/json', JSON.stringify(logs, null, 2));
    };
    exportCsvBtn.onclick = () => {
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      download(`activity_logs_${ts}.csv`, 'text/csv;charset=utf-8', toCSV(logs));
    };

    // Renders
    function renderActivities() {
      const current = activitySelect.value;
      activitySelect.innerHTML = '<option value="" disabled>Select activity</option>';
      activities.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a; opt.textContent = a;
        activitySelect.appendChild(opt);
      });
      if (current && activities.includes(current)) activitySelect.value = current;
      else activitySelect.selectedIndex = 0;

      activityList.innerHTML = '';
      activities.forEach((a,i) => {
        const li = document.createElement('li');
        li.className = 'flex justify-between items-center bg-gray-700 rounded px-2 py-1';
        li.innerHTML = `<span>${sanitize(a)}</span>
                        <button class="text-red-300 hover:text-red-200" aria-label="Delete activity ${sanitize(a)}" tabindex="0">‚úñ</button>`;
        const delBtn = li.querySelector('button');
        delBtn.onclick = () => {
          if (!confirm(`Delete "${a}"?`)) return;
          activities.splice(i,1);
          safeSave(STORAGE_KEYS.ACTIVITIES, activities);
          renderActivities();
        };
        delBtn.onkeydown = (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); delBtn.click(); }
        };
        activityList.appendChild(li);
      });
    }

    function renderLogs() {
      logDiv.innerHTML = '';
      logs.forEach(l => {
        const isThinking = l.status === 'thinking';
        const isFail = l.status === 'fail';
        const border = isThinking ? 'border-yellow-400' : isFail ? 'border-red-400' : 'border-green-400';
        const titleC = isThinking ? 'text-yellow-300' : isFail ? 'text-red-300' : 'text-green-300';
        const card = document.createElement('div');
        card.className = `bg-gray-800 p-3 rounded border-l-4 ${border}`;
        card.innerHTML = `
          <div class="flex justify-between items-center">
            <div class="font-semibold">${sanitize(l.activity)}</div>
            <div class="text-xs text-gray-400">${l.time}</div>
          </div>
          <div class="text-[11px] text-yellow-400 mt-0.5">AI Model: ${sanitize(l.model || 'N/A')}</div>
          <div class="${titleC} mt-1">${sanitize(l.feedback || '')}</div>
        `;
        logDiv.appendChild(card);
      });
      updateChart();
    }

    // Chart logic
    function countActivities() {
      const counts = {};
      for (const l of logs) {
        const a = l.activity || 'Unknown';
        counts[a] = (counts[a] || 0) + 1;
      }
      return counts;
    }

    function updateChart() {
      const counts = countActivities();
      const labels = Object.keys(counts);
      const data = Object.values(counts);
      const hasData = labels.length > 0 && data.reduce((s,n)=>s+n,0) > 0;

      if (!hasData) {
        chartCard.classList.add('hidden');
        if (pieChart) { pieChart.destroy(); pieChart = null; }
        return;
      }
      chartCard.classList.remove('hidden');

      const cfg = {
        type: 'pie',
        data: {
          labels,
          datasets: [{
            data,
            // No custom colors => Chart.js defaults (good contrast on dark)
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { labels: { color: '#e5e7eb' } }, // light text for dark bg
            tooltip: { enabled: true }
          }
        }
      };

      if (!pieChart) {
        if (!window.Chart) return; // Chart.js not loaded
        pieChart = new Chart(activityPieCanvas.getContext('2d'), cfg);
      } else {
        pieChart.data.labels = labels;
        pieChart.data.datasets[0].data = data;
        pieChart.update();
      }
    }

    // Model selection -> config
    function applyModelSelection() {
      const key = modelSelect.value;
      activeModelKey = key;
      const cfg = MODELS[key];
      activeModelId = cfg.id;
      activeTask   = cfg.task;
      modelBadge.textContent = cfg.badge;
      spinnerSub.textContent = `${cfg.note}, cached after first load`;
    }
    applyModelSelection();
    modelSelect.onchange = applyModelSelection;

    // Focus trap for modals
    function trapFocus(modal) {
      const focusable = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      if (!focusable.length) return () => {};
      const first = focusable[0], last = focusable[focusable.length - 1];
      function handler(e) {
        if (e.key !== 'Tab') return;
        if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
        else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
      }
      modal.addEventListener('keydown', handler);
      first.focus();
      return () => modal.removeEventListener('keydown', handler);
    }
    let untrap = () => {};

    // Load AI model (retries + backoff + device fallback)
    async function loadModel() {
      if (!navigator.onLine) { alert('‚ö†Ô∏è Offline. AI Coach needs internet.'); aiToggle.checked = false; return null; }
      if (!window.WebAssembly) { alert('‚ö†Ô∏è Browser lacks WebAssembly. Use Chrome/Firefox/Edge.'); aiToggle.checked = false; return null; }

      const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.2');
      const attempts = [0, 2000, 5000]; // backoff (ms)

      for (let i = 0; i < attempts.length; i++) {
        try {
          spinner.classList.remove('hidden');
          spinnerText.textContent = `Downloading ${activeModelId}‚Ä¶`;
          progressBar.style.width = '0%';
          spinner.setAttribute('aria-valuenow', '0');

          const cfg = MODELS[activeModelKey];
          const opts = {
            progress_callback: (p) => {
              if (p && p.loaded && p.total) {
                const pct = Math.floor((p.loaded / p.total) * 100);
                progressBar.style.width = pct + '%';
                spinnerText.textContent = `Downloading‚Ä¶ ${pct}%`;
                spinnerSub.textContent = `${(p.loaded/1e6).toFixed(1)}MB / ${(p.total/1e6).toFixed(1)}MB`;
                spinner.setAttribute('aria-valuenow', String(pct));
              }
            }
          };
          // First attempt uses WebGPU if available; subsequent attempts force CPU
          opts.device = (i === 0 && navigator.gpu) ? 'webgpu' : 'cpu';
          Object.assign(opts, cfg.opts);

          const gen = await Promise.race([
            pipeline(cfg.task, cfg.id, opts),
            new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), TIMEOUT_MS))
          ]);

          spinnerText.textContent = '‚úÖ AI Coach ready (cached)';
          setTimeout(() => spinner.classList.add('hidden'), 300);
          return gen;
        } catch (e) {
          console.warn(`Model load attempt ${i+1} failed:`, e.message);
          await new Promise(r => setTimeout(r, attempts[i]));
        } finally {
          setTimeout(() => spinner.classList.add('hidden'), 300);
        }
      }
      alert('‚ö†Ô∏è Failed to load AI Coach after multiple attempts. Using rule-based feedback.');
      aiToggle.checked = false;
      return null;
    }

    // Prompt
    function buildPrompt(activity) {
      const ask = `Give 2‚Äì4 short, specific, encouraging sentences about: "${activity}". Focus on momentum, next tiny step, and consistency.`;
      return activeTask === 'text2text-generation'
        ? ask
        : `You are a concise wellbeing coach. ${ask}`;
    }

    async function aiCoachFeedback(activity) {
      const input = buildPrompt(activity);
      const cores = navigator.hardwareConcurrency || 4;
      const GEN_MS = Math.min(30000, Math.max(12000, cores < 4 ? 20000 : BASE_GEN_TIMEOUT));
      try {
        const out = await Promise.race([
          generator(input, { max_new_tokens: 80 }),
          new Promise((_, rej) => setTimeout(() => rej(new Error('AI timeout')), GEN_MS))
        ]);
        let txt = out?.[0]?.generated_text || '';
        if (txt.startsWith(input)) txt = txt.slice(input.length);
        return limitSentences(txt.trim(), 4) || 'Keep it up!';
      } catch (e) {
        console.error('AI feedback fail:', e);
        return `‚ö†Ô∏è AI Coach error (${e.message}). ${ruleFeedback(activity)}`;
      }
    }

    // Events
    fabBtn.onclick = () => { logModal.classList.remove('hidden'); untrap = trapFocus(logModal); };
    manageBtn.onclick = () => { manageModal.classList.remove('hidden'); untrap = trapFocus(manageModal); };
    closeLog.onclick = () => { logModal.classList.add('hidden'); untrap(); };
    backBtn.onclick = () => { manageModal.classList.add('hidden'); untrap(); };

    // Close on ESC / outside
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') { logModal.classList.add('hidden'); manageModal.classList.add('hidden'); untrap(); }
    });
    window.addEventListener('click', (e) => {
      if (e.target === logModal) { logModal.classList.add('hidden'); untrap(); }
      if (e.target === manageModal) { manageModal.classList.add('hidden'); untrap(); }
    });

    clearBtn.onclick = () => {
      if (confirm('Clear all logs?')) {
        logs = [];
        safeSave(STORAGE_KEYS.LOGS, logs);
        renderLogs();
      }
    };

    addActivityBtn.onclick = debounce(() => {
      const val = newActivityInput.value.trim();
      if (!val) { alert('Enter activity.'); return; }
      if (activities.includes(val)) { alert('Activity exists.'); return; }
      activities.push(val);
      safeSave(STORAGE_KEYS.ACTIVITIES, activities);
      newActivityInput.value = '';
      renderActivities();
    }, 250);

    aiToggle.onchange = async () => {
      if (!aiToggle.checked) return;
      if (!generator) generator = await loadModel();
      if (generator) {
        const cfg = MODELS[activeModelKey];
        modelInfo.textContent = `Active: ${cfg.badge}${activeModelKey==='smollm2' ? ' (quantized bnb4)' : ''}`;
        modelInfo.classList.remove('hidden');
      }
    };

    logBtn.onclick = async () => {
      if (logBusy) return;
      logBusy = true;
      try {
        const act = activitySelect.value;
        if (!act) { alert('Please select an activity.'); return; }

        const aiOn = aiToggle.checked;

        // Direct rule-based when AI is off or generator missing
        if (!aiOn || !generator) {
          const entry = {
            activity: act,
            time: new Date().toLocaleString(),
            model: aiOn && !generator ? 'AI unavailable' : 'N/A',
            feedback: aiOn && !generator ? `‚ö†Ô∏è AI Coach unavailable. ${ruleFeedback(act)}` : ruleFeedback(act),
            status: aiOn && !generator ? 'fail' : 'done'
          };
          logs.push(entry);
          safeSave(STORAGE_KEYS.LOGS, logs);
          renderLogs();
          logModal.classList.add('hidden');
          return;
        }

        // AI path: show thinking, then replace
        const entry = {
          activity: act,
          time: new Date().toLocaleString(),
          model: MODELS[activeModelKey].badge + (activeModelKey==='smollm2' ? ' (bnb4)' : ''),
          feedback: 'ü§ñ AI Coach is thinking‚Ä¶',
          status: 'thinking'
        };
        logs.push(entry);
        safeSave(STORAGE_KEYS.LOGS, logs);
        renderLogs();

        try {
          const feedback = await aiCoachFeedback(act);
          entry.feedback = feedback;
          entry.status = feedback.startsWith('‚ö†Ô∏è') ? 'fail' : 'done';
        } catch (e) {
          entry.feedback = `‚ö†Ô∏è AI Coach error. ${ruleFeedback(act)}`;
          entry.status = 'fail';
        }

        safeSave(STORAGE_KEYS.LOGS, logs);
        renderLogs();
        logModal.classList.add('hidden');
      } finally {
        logBusy = false;
      }
    };

    // Init
    renderActivities();
    renderLogs();
  </script>
</body>
</html>
