<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beep & Flash Reminder – Random Reward</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root {
      --bg: #050510;
      --fg: #f5f5f5;
      --accent-1: #ff0044;
      --accent-2: #ff9900;
      --accent-3: #00e0ff;
      --accent-4: #5bff8a;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: radial-gradient(circle at top, #151530 0, #050510 50%, #000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--fg);
    }

    #container {
      width: 100%;
      max-width: 520px;
      text-align: center;
    }

    #flash-img {
      width: min(65vw, 320px);
      height: min(65vw, 320px);
      margin: 0 auto 20px;
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.8rem, 8vw, 3rem);
      font-weight: 800;
      letter-spacing: 0.18em;
      text-indent: 0.18em;
      text-shadow: 0 0 12px rgba(0, 0, 0, 0.8);
      box-shadow:
        0 0 40px rgba(255, 0, 80, 0.5),
        0 0 80px rgba(0, 224, 255, 0.3);
      background:
        radial-gradient(circle at 20% 20%, #fffd, transparent 60%),
        radial-gradient(circle at 80% 80%, #0ffb, transparent 60%),
        linear-gradient(135deg, var(--accent-1), var(--accent-2), var(--accent-3));
      color: #fff;
      user-select: none;
    }

    /* Flash animation */
    #flash-img.flash {
      animation: flicker 0.3s linear 3;
    }

    @keyframes flicker {
      0%, 100% {
        opacity: 1;
        filter:
          drop-shadow(0 0 10px #fff)
          drop-shadow(0 0 24px #ffff99);
      }
      50% {
        opacity: 0.2;
        filter:
          drop-shadow(0 0 4px #fff)
          drop-shadow(0 0 40px #ffdd55);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      #flash-img.flash {
        animation: none !important;
      }
    }

    button {
      padding: 10px 22px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      background: linear-gradient(135deg, var(--accent-3), var(--accent-4));
      color: #000;
      box-shadow: 0 0 16px rgba(0, 255, 160, 0.4);
      outline: none;
      min-width: 120px;
      touch-action: manipulation;
      transition: transform 0.05s ease, box-shadow 0.05s ease;
    }

    button:active {
      transform: scale(0.97);
      box-shadow: 0 0 8px rgba(0, 255, 160, 0.5);
    }

    button:disabled {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
    }

    #controls {
      margin: 16px auto 0;
      text-align: left;
      max-width: 420px;
      font-size: 0.9rem;
    }

    .control-row {
      margin-bottom: 10px;
    }

    .control-row label {
      display: block;
      margin-bottom: 4px;
      opacity: 0.9;
    }

    .control-inline {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-inline input[type="number"] {
      width: 80px;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.3);
      color: var(--fg);
      outline: none;
    }

    .unit {
      opacity: 0.8;
    }

    input[type="range"] {
      width: 100%;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider-value {
      min-width: 42px;
      text-align: right;
      opacity: 0.85;
    }

    .buttons-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }

    #status {
      margin-top: 12px;
      font-size: 0.85rem;
      opacity: 0.8;
      line-height: 1.4;
      text-align: center;
    }

    #countdown {
      margin-top: 4px;
      font-size: 0.8rem;
      opacity: 0.75;
      text-align: center;
    }

    .interval-desktop {
      display: block;
    }

    .interval-mobile {
      display: none;
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
    }

    .chip {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(5, 5, 16, 0.7);
      color: var(--fg);
      font-size: 0.8rem;
      cursor: pointer;
      touch-action: manipulation;
    }

    .chip-active {
      background: linear-gradient(135deg, var(--accent-3), var(--accent-4));
      color: #000;
      border-color: transparent;
      box-shadow: 0 0 10px rgba(0, 255, 160, 0.4);
    }

    .interval-inline {
      gap: 6px;
    }

    .interval-step-btn {
      width: 40px;
      height: 36px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(0, 0, 0, 0.5);
      color: var(--fg);
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
      touch-action: manipulation;
    }

    .interval-step-btn:active {
      transform: scale(0.96);
      box-shadow: 0 0 8px rgba(0, 255, 160, 0.5);
    }

    @media (pointer: coarse) {
      .interval-desktop {
        display: none;
      }
      .interval-mobile {
        display: block;
      }
    }

    @media (min-width: 900px) {
      #container {
        max-width: 560px;
      }
      #flash-img {
        width: 320px;
        height: 320px;
        font-size: 3rem;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="flash-img">ALERT</div>

    <div id="controls">
      <!-- Average interval -->
      <div class="control-row">
        <label for="interval-input-desktop">Average alert interval</label>

        <!-- Desktop -->
        <div class="interval-desktop">
          <div class="control-inline">
            <input
              type="number"
              id="interval-input-desktop"
              min="0.1"
              step="0.1"
              value="1"
              inputmode="decimal"
            />
            <span class="unit">minutes</span>
          </div>
        </div>

        <!-- Mobile -->
        <div class="interval-mobile">
          <div class="chip-row" aria-label="Quick interval presets">
            <button class="chip" type="button" data-minutes="0.5">0.5 min</button>
            <button class="chip chip-active" type="button" data-minutes="1">1 min</button>
            <button class="chip" type="button" data-minutes="2">2 min</button>
            <button class="chip" type="button" data-minutes="5">5 min</button>
          </div>

          <div class="control-inline interval-inline">
            <button
              class="interval-step-btn"
              type="button"
              id="interval-step-down"
              aria-label="Decrease interval"
            >
              −
            </button>

            <input
              type="number"
              id="interval-input-mobile"
              min="0.1"
              step="0.1"
              value="1"
              inputmode="decimal"
              pattern="[0-9]*[.,]?[0-9]*"
            />

            <button
              class="interval-step-btn"
              type="button"
              id="interval-step-up"
              aria-label="Increase interval"
            >
              +
            </button>

            <span class="unit">minutes</span>
          </div>
        </div>
      </div>

      <!-- Volume -->
      <div class="control-row">
        <label for="volume-input">Beep volume</label>
        <div class="slider-row">
          <input type="range" id="volume-input" min="0" max="100" value="25" />
          <span id="volume-value" class="slider-value">25%</span>
        </div>
      </div>

      <!-- Reward chance -->
      <div class="control-row">
        <label for="reward-input">Reward beep chance</label>
        <div class="slider-row">
          <input type="range" id="reward-input" min="0" max="100" value="33" />
          <span id="reward-value" class="slider-value">33%</span>
        </div>
      </div>

      <!-- Interval randomness -->
      <div class="control-row">
        <label for="randomness-input">Interval randomness</label>
        <div class="slider-row">
          <input type="range" id="randomness-input" min="0" max="100" value="50" />
          <span id="randomness-value" class="slider-value">50%</span>
        </div>
      </div>

      <!-- Vibration -->
      <div class="control-row">
        <label for="vibrate-toggle">Vibrate on alert (supported devices only)</label>
        <div class="control-inline">
          <input type="checkbox" id="vibrate-toggle" />
          <span class="unit">uses Vibration API</span>
        </div>
      </div>

      <!-- Start / Stop -->
      <div class="control-row buttons-row">
        <button id="start-btn" type="button">Start alerts</button>
        <button id="stop-btn" type="button" disabled>Stop</button>
      </div>
    </div>

    <p
      id="status"
      role="status"
      aria-live="polite"
      aria-atomic="true"
    >
      Set an average interval and tap “Start alerts”. Beeps occur at random times around that interval,
      with occasional higher-pitch reward beeps.
    </p>
    <p id="countdown" aria-live="polite"></p>
  </div>

  <script>
    (function () {
      "use strict";

      const BEEP_DURATION = 0.5;      // seconds
      const FLASH_DURATION = 1000;    // ms

      const MIN_INTERVAL_MINUTES = 0.1;
      const MAX_INTERVAL_MINUTES = 999;
      const INTERVAL_STEP_MINUTES = 0.1;
      const DEFAULT_INTERVAL_MINUTES = 1;
      const DEFAULT_VOLUME_PCT = 25;
      const DEFAULT_REWARD_CHANCE_PCT = 33; // ≈ 1 in 3
      const DEFAULT_RANDOMNESS_PCT = 50;

      const BASE_FREQUENCY = 440;     // Hz
      const REWARD_FREQUENCY = 880;   // Hz

      const SETTINGS_KEY = "beep_flash_random_reward_v1";

      const isCoarsePointer =
        (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) ||
        /Android|iPhone|iPad|iPod/i.test(navigator.userAgent || "");

      const flashImg = document.getElementById("flash-img");
      const startBtn = document.getElementById("start-btn");
      const stopBtn = document.getElementById("stop-btn");
      const statusEl = document.getElementById("status");
      const volumeInput = document.getElementById("volume-input");
      const volumeValue = document.getElementById("volume-value");
      const rewardInput = document.getElementById("reward-input");
      const rewardValue = document.getElementById("reward-value");
      const randomnessInput = document.getElementById("randomness-input");
      const randomnessValue = document.getElementById("randomness-value");
      const vibrateToggle = document.getElementById("vibrate-toggle");
      const countdownEl = document.getElementById("countdown");

      const intervalInputDesktop = document.getElementById("interval-input-desktop");
      const intervalInputMobile = document.getElementById("interval-input-mobile");
      const intervalInput = isCoarsePointer ? intervalInputMobile : intervalInputDesktop;

      const intervalStepDown = isCoarsePointer
        ? document.getElementById("interval-step-down")
        : null;
      const intervalStepUp = isCoarsePointer
        ? document.getElementById("interval-step-up")
        : null;
      const intervalChips = isCoarsePointer
        ? Array.from(document.querySelectorAll(".chip-row .chip"))
        : [];

      const vibrateDescription = document.querySelector("#vibrate-toggle + .unit");
      const supportsVibration = !!navigator.vibrate;

      let audioCtx = null;
      let warnedNoAudio = false;

      let timeoutId = null;
      let running = false;

      let volume = volumeInput.value / 100;
      let rewardChance = rewardInput.value / 100;
      let randomnessFraction = randomnessInput.value / 100;

      let nextTickAt = null;
      let rafId = null;
      let lastCountdownSeconds = null;

      // Countdown is always visible
      countdownEl.textContent = "No alert scheduled.";

      if (!supportsVibration && vibrateToggle) {
        vibrateToggle.disabled = true;
        if (vibrateDescription) {
          vibrateDescription.textContent = "Vibration not supported on this device";
        }
      }

      function setIntervalInputs(minutes) {
        const value = minutes.toString();
        if (intervalInputDesktop) intervalInputDesktop.value = value;
        if (intervalInputMobile) intervalInputMobile.value = value;
      }

      function ensureAudioContext() {
        if (!("AudioContext" in window || "webkitAudioContext" in window)) {
          if (!warnedNoAudio) {
            warnedNoAudio = true;
            statusEl.textContent =
              "This browser does not support the Web Audio API. Visual flash and vibration will work, but not the beep.";
          }
          return;
        }
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } else if (audioCtx.state === "suspended") {
          audioCtx.resume();
        }
      }

      function sanitizeIntervalMinutes() {
        if (!intervalInput) return null;
        let raw = (intervalInput.value || "").toString().trim().replace(",", ".");
        let minutes = parseFloat(raw);
        if (isNaN(minutes) || minutes <= 0) return null;
        minutes = Math.min(Math.max(minutes, MIN_INTERVAL_MINUTES), MAX_INTERVAL_MINUTES);
        return minutes;
      }

      function getEffectiveMinutes() {
        const minutes = sanitizeIntervalMinutes();
        return minutes === null ? DEFAULT_INTERVAL_MINUTES : minutes;
      }

      function computeRandomIntervalMs() {
        const meanMinutes = getEffectiveMinutes();
        const meanMs = meanMinutes * 60000;

        if (randomnessFraction <= 0) {
          return meanMs;
        }

        const delta = meanMs * randomnessFraction; // +/- fraction of mean
        const offset = (Math.random() * 2 - 1) * delta;
        let candidate = meanMs + offset;

        const minMs = MIN_INTERVAL_MINUTES * 60000;
        const maxMs = MAX_INTERVAL_MINUTES * 60000;
        candidate = Math.max(minMs, Math.min(maxMs, candidate));

        return candidate;
      }

      function updateActiveChip(minutes) {
        if (!intervalChips.length) return;
        let matched = false;
        intervalChips.forEach((chip) => {
          const m = parseFloat(chip.dataset.minutes);
          const isActive = Math.abs(m - minutes) < 1e-6;
          chip.classList.toggle("chip-active", isActive);
          if (isActive) matched = true;
        });
        if (!matched) {
          intervalChips.forEach((chip) => chip.classList.remove("chip-active"));
        }
      }

      function playTone(frequency) {
        if (volume <= 0) return;

        ensureAudioContext();
        if (!audioCtx) return;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = "sine";
        osc.frequency.value = frequency;
        gain.gain.value = volume;

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        osc.stop(audioCtx.currentTime + BEEP_DURATION);
      }

      function beepWithReward() {
        const isReward = Math.random() < rewardChance;
        const freq = isReward ? REWARD_FREQUENCY : BASE_FREQUENCY;
        playTone(freq);

        if (isReward) {
          statusEl.textContent =
            "Reward beep! High pitch at " +
            REWARD_FREQUENCY +
            " Hz. Random schedule still running.";
        }
      }

      function flash() {
        flashImg.classList.add("flash");
        setTimeout(() => flashImg.classList.remove("flash"), FLASH_DURATION);
      }

      function vibrateOnce() {
        if (!supportsVibration) return;
        if (!vibrateToggle.checked) return;
        try {
          navigator.vibrate([160, 80, 160]);
        } catch (_) {
          /* ignore */
        }
      }

      function updateCountdown() {
        if (!running || !nextTickAt) {
          countdownEl.textContent = running
            ? "No alert scheduled."
            : "No alert scheduled.";
          lastCountdownSeconds = null;
          return;
        }

        const now = performance.now();
        const msLeft = Math.max(0, nextTickAt - now);
        const seconds = Math.round(msLeft / 1000);
        if (seconds !== lastCountdownSeconds) {
          countdownEl.textContent = "Next alert in " + seconds + " second(s)";
          lastCountdownSeconds = seconds;
        }
        rafId = requestAnimationFrame(updateCountdown);
      }

      function startCountdown(intervalMs) {
        nextTickAt = performance.now() + intervalMs;
        if (rafId) cancelAnimationFrame(rafId);
        lastCountdownSeconds = null;
        updateCountdown();
      }

      function stopCountdown() {
        nextTickAt = null;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
        countdownEl.textContent = "No alert scheduled.";
        lastCountdownSeconds = null;
      }

      function updateRunningStatus() {
        const avgMinutes = getEffectiveMinutes();
        const randomnessPct = Math.round(randomnessFraction * 100);
        const rewardPct = Math.round(rewardChance * 100);
        statusEl.textContent =
          "Running: random beep schedule around " +
          avgMinutes.toFixed(2).replace(/\.00$/, "") +
          " minute(s), " +
          randomnessPct +
          "% variability, reward beeps at " +
          rewardPct +
          "% chance. Keep this tab open and sound on.";
      }

      function scheduleNextBeepFromNow() {
        if (!running) return;
        if (timeoutId !== null) clearTimeout(timeoutId);

        const intervalMs = computeRandomIntervalMs();
        startCountdown(intervalMs);
        updateRunningStatus();

        timeoutId = setTimeout(alertTick, intervalMs);
      }

      function doAlertOnce() {
        beepWithReward();
        flash();
        vibrateOnce();
      }

      function alertTick() {
        if (!running) return;
        doAlertOnce();
        scheduleNextBeepFromNow();
      }

      function loadSettings() {
        try {
          const raw = localStorage.getItem(SETTINGS_KEY);
          if (!raw) return;
          const s = JSON.parse(raw);
          if (typeof s.intervalMinutes === "number" && s.intervalMinutes > 0) {
            setIntervalInputs(s.intervalMinutes);
          }
          if (
            typeof s.volumePct === "number" &&
            s.volumePct >= 0 &&
            s.volumePct <= 100
          ) {
            volumeInput.value = s.volumePct;
            volume = s.volumePct / 100;
            volumeValue.textContent = s.volumePct + "%";
          }
          if (
            typeof s.rewardChancePct === "number" &&
            s.rewardChancePct >= 0 &&
            s.rewardChancePct <= 100
          ) {
            rewardInput.value = s.rewardChancePct;
            rewardChance = s.rewardChancePct / 100;
            rewardValue.textContent = s.rewardChancePct + "%";
          }
          if (
            typeof s.randomnessPct === "number" &&
            s.randomnessPct >= 0 &&
            s.randomnessPct <= 100
          ) {
            randomnessInput.value = s.randomnessPct;
            randomnessFraction = s.randomnessPct / 100;
            randomnessValue.textContent = s.randomnessPct + "%";
          }
          if (typeof s.vibrateOn === "boolean") {
            vibrateToggle.checked = s.vibrateOn && supportsVibration;
          }
        } catch (e) {
          /* ignore */
        }
      }

      function saveSettings() {
        const minutes = sanitizeIntervalMinutes();
        const volumePct = parseInt(volumeInput.value, 10);
        const rewardPct = parseInt(rewardInput.value, 10);
        const randomPct = parseInt(randomnessInput.value, 10);
        const data = {
          intervalMinutes: minutes === null ? DEFAULT_INTERVAL_MINUTES : minutes,
          volumePct: isNaN(volumePct) ? DEFAULT_VOLUME_PCT : volumePct,
          rewardChancePct: isNaN(rewardPct) ? DEFAULT_REWARD_CHANCE_PCT : rewardPct,
          randomnessPct: isNaN(randomPct) ? DEFAULT_RANDOMNESS_PCT : randomPct,
          vibrateOn: !!vibrateToggle.checked,
        };
        try {
          localStorage.setItem(SETTINGS_KEY, JSON.stringify(data));
        } catch (e) {
          /* ignore */
        }
      }

      function applyIntervalChange() {
        const effectiveMinutes = getEffectiveMinutes();
        setIntervalInputs(effectiveMinutes);
        saveSettings();
        updateActiveChip(effectiveMinutes);

        if (running) {
          scheduleNextBeepFromNow();
        }
      }

      // Start / stop
      startBtn.addEventListener("click", () => {
        if (running) return;

        ensureAudioContext();
        running = true;

        // Immediate first alert
        doAlertOnce();
        scheduleNextBeepFromNow();

        startBtn.disabled = true;
        stopBtn.disabled = false;
      });

      stopBtn.addEventListener("click", () => {
        if (!running) return;

        running = false;
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        stopCountdown();
        startBtn.disabled = false;
        stopBtn.disabled = true;
        statusEl.textContent =
          "Stopped. Adjust interval, randomness, volume, reward chance, or vibration and press “Start alerts” when ready.";
      });

      // Volume
      volumeInput.addEventListener("input", () => {
        const pct = parseInt(volumeInput.value, 10);
        const clamped = isNaN(pct) ? DEFAULT_VOLUME_PCT : Math.min(100, Math.max(0, pct));
        volumeInput.value = clamped;
        volume = clamped / 100;
        volumeValue.textContent = clamped + "%";
        saveSettings();
      });

      // Reward chance
      rewardInput.addEventListener("input", () => {
        const pct = parseInt(rewardInput.value, 10);
        const clamped = isNaN(pct) ? DEFAULT_REWARD_CHANCE_PCT : Math.min(100, Math.max(0, pct));
        rewardInput.value = clamped;
        rewardChance = clamped / 100;
        rewardValue.textContent = clamped + "%";
        saveSettings();
        if (running) updateRunningStatus();
      });

      // Randomness
      randomnessInput.addEventListener("input", () => {
        const pct = parseInt(randomnessInput.value, 10);
        const clamped = isNaN(pct) ? DEFAULT_RANDOMNESS_PCT : Math.min(100, Math.max(0, pct));
        randomnessInput.value = clamped;
        randomnessFraction = clamped / 100;
        randomnessValue.textContent = clamped + "%";
        saveSettings();
        if (running) updateRunningStatus();
      });

      // Interval input
      if (intervalInput) {
        intervalInput.addEventListener("change", () => {
          applyIntervalChange();
        });

        intervalInput.addEventListener("input", () => {
          const minutes = sanitizeIntervalMinutes();
          if (minutes !== null) {
            updateActiveChip(minutes);
          } else {
            updateActiveChip(0);
          }
        });
      }

      // Mobile-only: chips and +/- buttons
      if (isCoarsePointer) {
        intervalChips.forEach((chip) => {
          chip.addEventListener("click", () => {
            const minutes = parseFloat(chip.dataset.minutes);
            if (!isNaN(minutes)) {
              setIntervalInputs(minutes);
              applyIntervalChange();
            }
          });
        });

        if (intervalStepDown) {
          intervalStepDown.addEventListener("click", () => {
            let minutes = sanitizeIntervalMinutes();
            if (minutes === null) minutes = DEFAULT_INTERVAL_MINUTES;
            minutes = Math.max(MIN_INTERVAL_MINUTES, minutes - INTERVAL_STEP_MINUTES);
            setIntervalInputs(minutes);
            applyIntervalChange();
          });
        }

        if (intervalStepUp) {
          intervalStepUp.addEventListener("click", () => {
            let minutes = sanitizeIntervalMinutes();
            if (minutes === null) minutes = DEFAULT_INTERVAL_MINUTES;
            minutes = Math.min(MAX_INTERVAL_MINUTES, minutes + INTERVAL_STEP_MINUTES);
            setIntervalInputs(minutes);
            applyIntervalChange();
          });
        }
      }

      // Vibrate toggle
      vibrateToggle.addEventListener("change", () => {
        saveSettings();
        if (running) {
          updateRunningStatus();
        }
      });

      // Resume audio on interaction (mobile)
      ["touchstart", "click"].forEach((evt) =>
        document.addEventListener(
          evt,
          () => {
            if (audioCtx && audioCtx.state === "suspended") {
              audioCtx.resume();
            }
          },
          { passive: true }
        )
      );

      // Init
      loadSettings();
      const initialMinutes = sanitizeIntervalMinutes();
      if (initialMinutes !== null) {
        updateActiveChip(initialMinutes);
      }
    })();
  </script>
</body>
</html>
