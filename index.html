<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebLLM Local Browser Chat</title>

  <!-- Markdown Parser (optional, for nicer bot output) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" crossorigin="anonymous" defer></script>

  <style>
    :root {
      --bg: #0f172a;
      --chat-bg: #1e293b;
      --input-bg: #334155;
      --accent: #3b82f6;
      --text: #f8fafc;
      --user-msg: #2563eb;
      --muted: #94a3b8;
      --danger: #ef4444;
      --warn: #f59e0b;
      --ok: #22c55e;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* --- Loading Screen --- */
    #loader {
      position: absolute;
      inset: 0;
      background: var(--bg);
      z-index: 50;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.5s ease;
    }

    .loader-box {
      background: var(--chat-bg);
      padding: 1.6rem;
      border-radius: 12px;
      width: 92%;
      max-width: 720px;
      text-align: left;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border: 1px solid var(--input-bg);
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 700;
    }

    .pill {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(51,65,85,0.9);
      background: rgba(2,6,23,0.35);
      color: #cbd5e1;
      white-space: nowrap;
    }

    .progress-bar-bg {
      width: 100%;
      height: 8px;
      background: #020617;
      border-radius: 4px;
      margin-top: 14px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.2s;
    }

    .status {
      margin: 10px 0 0;
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.35;
    }

    .hint {
      margin: 10px 0 0;
      font-size: 0.86rem;
      line-height: 1.35;
      color: #cbd5e1;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(2,6,23,0.30);
      padding: 10px;
      border-radius: 10px;
    }

    .hint b { color: #e2e8f0; }

    .actions {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
    }

    button.secondary {
      background: rgba(2,6,23,0.35);
      border: 1px solid rgba(51,65,85,0.9);
      color: #e2e8f0;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    details {
      margin-top: 12px;
      border: 1px solid rgba(51,65,85,0.7);
      background: rgba(2,6,23,0.35);
      border-radius: 10px;
      padding: 10px;
      color: #cbd5e1;
    }

    summary {
      cursor: pointer;
      font-weight: 700;
      color: #e2e8f0;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin-top: 8px;
      color: #cbd5e1;
    }

    /* --- Chat Interface --- */
    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
      opacity: 0;
      transition: opacity 0.5s;
    }

    header {
      padding: 15px 20px;
      background: var(--chat-bg);
      border-bottom: 1px solid var(--input-bg);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .badge {
      font-size: 0.75rem;
      background: #0f172a;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid var(--input-bg);
      color: var(--muted);
      white-space: nowrap;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      scroll-behavior: smooth;
    }

    .msg {
      max-width: 85%;
      padding: 10px 16px;
      border-radius: 10px;
      line-height: 1.5;
      font-size: 0.95rem;
      animation: fadeIn 0.2s ease;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    .msg p { margin: 0; }
    .msg pre { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; overflow-x: auto; }

    .user {
      align-self: flex-end;
      background: var(--user-msg);
      color: white;
      border-bottom-right-radius: 2px;
      white-space: pre-wrap;
    }

    .bot {
      align-self: flex-start;
      background: var(--chat-bg);
      border: 1px solid var(--input-bg);
      border-bottom-left-radius: 2px;
      white-space: pre-wrap;
    }

    #input-area {
      padding: 20px;
      background: var(--chat-bg);
      border-top: 1px solid var(--input-bg);
      display: flex;
      gap: 10px;
    }

    input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--input-bg);
      color: white;
      padding: 12px;
      border-radius: 8px;
      outline: none;
      font-size: 1rem;
    }

    input:focus { border-color: var(--accent); }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>

  <!--
    COI bootstrap via Service Worker.
    This can only work in a top-level browsing context served over http(s).
    In embedded previews/iframes, browsers typically won't grant crossOriginIsolated.
  -->
  <script>
    (function setupCOIServiceWorker() {
      window.__coi = { state: "init", error: "" };

      if (window.crossOriginIsolated) {
        window.__coi.state = "ok";
        return;
      }

      const embedded = (function() {
        try { return window.top !== window.self; } catch { return true; }
      })();
      if (embedded) {
        window.__coi.state = "embedded";
        return;
      }

      if (!('serviceWorker' in navigator)) {
        window.__coi.state = "no-sw";
        return;
      }

      const reloadKey = "__coi_reload_done_v2";
      const alreadyReloaded = sessionStorage.getItem(reloadKey) === '1';

      const workerScript = `
self.addEventListener('install', () => self.skipWaiting());
self.addEventListener('activate', (e) => e.waitUntil(self.clients.claim()));
self.addEventListener('fetch', (e) => {
  if (e.request.cache === 'only-if-cached' && e.request.mode !== 'same-origin') return;
  e.respondWith((async () => {
    const res = await fetch(e.request);
    if (!res || res.status === 0) return res;
    const headers = new Headers(res.headers);
    headers.set('Cross-Origin-Opener-Policy', 'same-origin');
    headers.set('Cross-Origin-Embedder-Policy', 'credentialless');
    return new Response(res.body, { status: res.status, statusText: res.statusText, headers });
  })());
});
      `;

      const url = URL.createObjectURL(new Blob([workerScript], { type: 'application/javascript' }));
      navigator.serviceWorker.register(url, { scope: './' }).then(() => {
        window.__coi.state = "sw-registered";
        if (!navigator.serviceWorker.controller && !alreadyReloaded) {
          sessionStorage.setItem(reloadKey, '1');
          location.reload();
        }
      }).catch((err) => {
        window.__coi.state = "sw-error";
        window.__coi.error = String(err && err.message ? err.message : err);
      });
    })();
  </script>

  <!--
    Robustness patch:
    Some environments throw "Failed to execute 'add' on 'Cache': Request failed".
    Make Cache.add/AddAll non-fatal.
  -->
  <script>
    (function patchCacheAddNonFatal() {
      if (!('caches' in window)) return;
      const origOpen = caches.open.bind(caches);
      caches.open = async function(...args) {
        const cache = await origOpen(...args);
        if (cache.__patched_add) return cache;
        cache.__patched_add = true;
        const origAdd = cache.add ? cache.add.bind(cache) : null;
        const origAddAll = cache.addAll ? cache.addAll.bind(cache) : null;

        if (origAdd) {
          cache.add = async (req) => {
            try { return await origAdd(req); }
            catch { return undefined; }
          };
        }
        if (origAddAll) {
          cache.addAll = async (reqs) => {
            for (const r of reqs) { try { await cache.add(r); } catch {} }
            return undefined;
          };
        }
        return cache;
      };
    })();
  </script>
</head>
<body>
  <!-- Loader -->
  <div id="loader">
    <div class="loader-box">
      <div class="row">
        <h2 class="h2">WebLLM Local Browser Chat</h2>
        <span class="pill" id="env-pill">Env: detecting…</span>
      </div>

      <p class="status" id="status-text">Preparing…</p>

      <div class="progress-bar-bg">
        <div id="progress" class="progress-bar"></div>
      </div>
      <p id="pct" style="margin:6px 0 0; font-size:0.8rem; color:#64748b;">0%</p>

      <div class="hint" id="hint" style="display:none"></div>

      <div class="actions">
        <button id="open-standalone" class="secondary" type="button">Open standalone</button>
        <button id="reload" class="secondary" type="button">Reload</button>
        <button id="copy-url" class="secondary" type="button">Copy URL</button>
      </div>

      <details>
        <summary>Diagnostics</summary>
        <div class="mono" id="diag">(waiting)</div>
      </details>
    </div>
  </div>

  <!-- Main App -->
  <div id="app">
    <header>
      <div style="display:flex; flex-direction:column; gap:2px;">
        <div style="font-weight:700;">LocalChat</div>
        <div style="font-size:0.8rem; color:var(--muted);" id="header-sub">WebLLM</div>
      </div>
      <div class="badge" id="model-badge">Model: (loading…)</div>
    </header>

    <div id="messages"></div>

    <div id="input-area">
      <input type="text" id="user-input" placeholder="Type a message…" autocomplete="off" />
      <button id="send-btn">Send</button>
    </div>
  </div>

  <script type="module">
    const $ = (id) => document.getElementById(id);

    const $loader = $("loader");
    const $app = $("app");
    const $status = $("status-text");
    const $progress = $("progress");
    const $pct = $("pct");
    const $hint = $("hint");
    const $diag = $("diag");
    const $envPill = $("env-pill");

    const $openStandalone = $("open-standalone");
    const $reload = $("reload");
    const $copyUrl = $("copy-url");

    const $msgs = $("messages");
    const $input = $("user-input");
    const $btn = $("send-btn");
    const $modelBadge = $("model-badge");
    const $headerSub = $("header-sub");

    // ===== Unit tests =====
    function assert(name, cond) {
      if (!cond) throw new Error("Test failed: " + name);
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function isEmbedded() {
      try { return window.top !== window.self; } catch { return true; }
    }

    function runUnitTests() {
      assert("escapeHtml amp", escapeHtml("&") === "&amp;");
      assert("escapeHtml lt", escapeHtml("<") === "&lt;");
      assert("escapeHtml gt", escapeHtml(">") === "&gt;");
      assert("escapeHtml quote", escapeHtml('"') === "&quot;");
      assert("newline replace works", ("a\n b").replaceAll("\n", "<br/>") === "a<br/> b");
      assert("isEmbedded returns boolean", typeof isEmbedded() === "boolean");
      assert("DOM loader exists", !!$loader);
      assert("DOM status exists", !!$status);
      return true;
    }

    // ===== UI helpers =====
    function setProgress(p01, text) {
      const pct = Math.max(0, Math.min(100, Math.floor((Number(p01) || 0) * 100)));
      $progress.style.width = pct + "%";
      $pct.textContent = pct + "%";
      if (text) $status.textContent = text;
    }

    function showHint(html) {
      $hint.style.display = "block";
      $hint.innerHTML = html;
    }

    function appendMessage(role, text) {
      const div = document.createElement("div");
      div.className = `msg ${role === 'user' ? 'user' : 'bot'}`;
      if (role === 'user') {
        div.textContent = text;
      } else {
        const markedOk = (window.marked && typeof window.marked.parse === 'function');
        div.innerHTML = markedOk ? window.marked.parse(text) : escapeHtml(text).replaceAll("\n", "<br/>");
      }
      $msgs.appendChild(div);
      $msgs.scrollTop = $msgs.scrollHeight;
      return div;
    }

    function showApp() {
      $loader.style.opacity = "0";
      setTimeout(() => {
        $loader.style.display = "none";
        $app.style.opacity = "1";
      }, 450);
    }

    function updateDiag(obj) {
      $diag.textContent = Object.entries(obj).map(([k, v]) => `${k}: ${v}`).join("\n");
    }

    // ===== Actions =====
    $openStandalone.addEventListener('click', () => {
      window.open(location.href, '_blank', 'noopener,noreferrer');
    });

    $reload.addEventListener('click', () => location.reload());

    $copyUrl.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(location.href);
        $copyUrl.textContent = 'Copied';
        setTimeout(() => ($copyUrl.textContent = 'Copy URL'), 900);
      } catch {
        $copyUrl.textContent = 'Copy failed';
        setTimeout(() => ($copyUrl.textContent = 'Copy URL'), 1200);
      }
    });

    // ===== WebLLM setup =====
    function pickModelIdFromList(modelList) {
      const ids = (modelList || []).map(m => m.model_id).filter(Boolean);
      // Prefer Qwen + 0.5B + Instruct + q4f32_1
      const best = ids.find(id => /qwen/i.test(id) && /0\.5b/i.test(id) && /instruct/i.test(id) && /q4f32_1/i.test(id));
      if (best) return best;
      const next = ids.find(id => /qwen/i.test(id) && /0\.5b/i.test(id) && /instruct/i.test(id));
      if (next) return next;
      const anyQwen = ids.find(id => /qwen/i.test(id));
      if (anyQwen) return anyQwen;
      const small = ids.find(id => /gemma-2b|phi-3-mini|phi-2|tiny/i.test(id));
      return small || ids[0] || null;
    }

    function rewriteRawGitHubToJsDelivr(url) {
      const rawPrefix = "https://raw.githubusercontent.com/mlc-ai/binary-mlc-llm-libs/main/";
      if (!url || typeof url !== 'string') return url;
      if (url.startsWith(rawPrefix)) {
        const rest = url.slice(rawPrefix.length);
        return "https://cdn.jsdelivr.net/gh/mlc-ai/binary-mlc-llm-libs@main/" + rest;
      }
      return url;
    }

    function buildPatchedAppConfig(webllm, modelId) {
      const base = webllm.prebuiltAppConfig;
      const rec = base?.model_list?.find(m => m.model_id === modelId);
      if (!rec) return null;
      const patched = { ...rec };
      patched.model_lib = rewriteRawGitHubToJsDelivr(patched.model_lib);
      return { model_list: [patched] };
    }

    async function loadWebLLM() {
      try {
        return await import("https://cdn.jsdelivr.net/npm/@mlc-ai/web-llm@0.2.80/+esm");
      } catch {
        return await import("https://esm.run/@mlc-ai/web-llm@0.2.80");
      }
    }

    // ===== Main =====
    let webllm;
    let engine;
    const messages = [{ role: 'system', content: 'You are a helpful and concise AI assistant.' }];

    async function initialize() {
      try {
        runUnitTests();
      } catch (e) {
        setProgress(0, "Unit tests failed.");
        showHint(`<b>Code bug:</b> ${escapeHtml(e.message)}.`);
        updateDiag({ error: e.message });
        return;
      }

      const embedded = isEmbedded();
      const coi = window.crossOriginIsolated;
      const swState = window.__coi?.state || 'unknown';

      $envPill.textContent = embedded ? "Env: embedded" : "Env: top-level";

      updateDiag({
        embedded,
        protocol: location.protocol,
        crossOriginIsolated: coi,
        serviceWorkerController: !!navigator.serviceWorker?.controller,
        coiBootstrapState: swState,
        userAgent: navigator.userAgent,
        webgpu: !!navigator.gpu,
      });

      if (embedded && !coi) {
        setProgress(0, "Blocked: crossOriginIsolated is false (embedded preview)." );
        showHint(
          `<b>This page is running inside an embedded preview.</b><br/>` +
          `WebLLM needs <span class="mono">crossOriginIsolated = true</span> (COOP+COEP). In embedded previews/iframes, browsers typically won't grant COI.<br/><br/>` +
          `<b>Fix:</b> click <b>Open standalone</b> and run it as a top-level page over <b>http(s)</b> (ideally <b>localhost</b>).`
        );
        return;
      }

      if (!coi) {
        setProgress(0, "Blocked: crossOriginIsolated is false." );
        showHint(
          `<b>Cross-origin isolation is not enabled.</b><br/>` +
          `This is required for SharedArrayBuffer/WebLLM. If you opened this from <b>file://</b>, service workers cannot run.<br/><br/>` +
          `<b>Recommended:</b><br/>` +
          `<div class="mono">python -m http.server 8000</div>` +
          `Then open: <span class="mono">http://localhost:8000/</span> and refresh once.`
        );
        return;
      }

      if (!navigator.gpu) {
        setProgress(0, "Error: WebGPU not available." );
        showHint(`Enable WebGPU in Chrome/Edge. WebLLM requires WebGPU.`);
        return;
      }

      setProgress(0.02, "Loading WebLLM runtime…");
      webllm = await loadWebLLM();
      $headerSub.textContent = `WebLLM ${webllm.version ? 'v' + webllm.version : ''}`;

      const modelId = pickModelIdFromList(webllm.prebuiltAppConfig?.model_list || []);
      if (!modelId) {
        setProgress(0, "Error: No models available." );
        showHint(`No models were found in prebuiltAppConfig.`);
        return;
      }

      $modelBadge.textContent = `Model: ${modelId}`;

      const initProgressCallback = (info) => {
        const p = Number(info?.progress ?? 0);
        const text = String(info?.text ?? 'Loading…');
        setProgress(p, text);
      };

      try {
        setProgress(0.04, `Initializing engine (${modelId})…`);
        engine = await webllm.CreateMLCEngine(modelId, { initProgressCallback });
      } catch (err1) {
        try {
          const patched = buildPatchedAppConfig(webllm, modelId);
          if (!patched) throw err1;
          setProgress(0.04, `Retrying with patched model_lib mirror…`);
          engine = await webllm.CreateMLCEngine(modelId, { initProgressCallback, appConfig: patched });
        } catch (err2) {
          const msg = (err2 && err2.message) ? err2.message : String(err2);
          setProgress(0, "Error initializing model." );
          showHint(`<b>Init failed:</b> ${escapeHtml(msg)}`);
          updateDiag({
            embedded,
            crossOriginIsolated: coi,
            webgpu: !!navigator.gpu,
            selectedModel: modelId,
            error: msg,
          });
          return;
        }
      }

      showApp();
      appendMessage('assistant', `Loaded <b>${modelId}</b> locally in your browser. Ask me something.`);
      $input.focus();
    }

    async function handleSend() {
      const text = $input.value.trim();
      if (!text || !engine) return;

      $input.value = '';
      $input.disabled = true;
      $btn.disabled = true;

      appendMessage('user', text);
      messages.push({ role: 'user', content: text });

      const botBubble = appendMessage('assistant', '…');
      let full = '';

      try {
        const chunks = await engine.chat.completions.create({
          messages,
          stream: true,
          temperature: 0.7,
        });

        for await (const chunk of chunks) {
          const part = chunk?.choices?.[0]?.delta?.content || '';
          if (!part) continue;
          full += part;
          const markedOk = (window.marked && typeof window.marked.parse === 'function');
          botBubble.innerHTML = markedOk ? window.marked.parse(full) : escapeHtml(full).replaceAll("\n", "<br/>");
          $msgs.scrollTop = $msgs.scrollHeight;
        }

        messages.push({ role: 'assistant', content: full });
      } catch (err) {
        const msg = (err && err.message) ? err.message : String(err);
        botBubble.innerHTML = `<b>Error:</b> ${escapeHtml(msg)}`;
      } finally {
        $input.disabled = false;
        $btn.disabled = false;
        $input.focus();
      }
    }

    $btn.addEventListener('click', handleSend);
    $input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    });

    initialize();
  </script>
</body>
</html>
